<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EveXa Income-Expense Tracker - Your Personal Finance Manager</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="EveXa Income-Expense Tracker: Smartly manage your income, track expenses (needs vs. wants), set personalized budgets, schedule recurring bills, and export financial reports. Achieve your financial goals with EveXa!">
    <meta name="keywords" content="income tracker, expense tracker, budget app, personal finance, money management, needs wants, recurring bills, financial planner, savings tracker, custom categories, financial goals, EveXa, free finance app">
    <meta name="author" content="EveXa Solutions">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#4F46E5"> <!-- Primary color for browser theme -->

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- jsPDF and html2canvas CDNs for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e0e7ff; /* Light indigo */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #818cf8; /* Medium indigo */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6366f1; /* Darker indigo */
        }

        /* Loader specific styles */
        .animate-spin-slow {
            animation: spin 3s linear infinite;
        }
        .animate-spin-fast {
            animation: spin 1.5s linear infinite reverse;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Glassmorphism effect base style */
        .glass-effect {
            background-color: rgba(255, 255, 255, 0.6); /* Semi-transparent white */
            backdrop-filter: blur(10px); /* Frosted glass blur */
            border: 1px solid rgba(255, 255, 255, 0.3); /* Subtle white border */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Soft shadow */
        }

        /* Specific adjustments for different elements */
        #mainAppContent {
            background-color: rgba(255, 255, 255, 0.7); /* Slightly more opaque for main content */
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        /* Adjust internal sections */
        .section-glass-effect {
            background-color: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* Adjust modals */
        .modal-glass-effect {
            background-color: rgba(255, 255, 255, 0.85); /* More opaque for modals */
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }

        /* Carousel specific styles */
        .carousel-item {
            display: none; /* Hide all by default */
        }
        .carousel-item.active {
            display: block; /* Show active item */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6 md:p-8">

    <!-- EveXa Loader -->
    <div id="appLoader" class="fixed inset-0 bg-indigo-700 flex flex-col items-center justify-center z-[200] transition-opacity duration-500 ease-out">
        <div class="animate-pulse text-white text-4xl sm:text-5xl md:text-6xl font-bold mb-4">
            EveXa
        </div>
        <div class="text-white text-xl sm:text-2xl font-light tracking-wide">
            Income-Expense Tracker
        </div>
        <div class="mt-8 relative w-24 h-24">
            <div class="loader-circle absolute border-4 border-t-4 border-white border-opacity-30 rounded-full w-full h-full animate-spin-slow"></div>
            <div class="loader-inner-circle absolute border-4 border-t-4 border-indigo-300 rounded-full w-1/2 h-1/2 left-1/4 top-1/4 animate-spin-fast"></div>
        </div>
    </div>


    <!-- Main Application Container -->
    <div id="mainAppContent" class="glass-effect shadow-xl rounded-2xl p-4 sm:p-6 md:p-10 w-full max-w-4xl mx-auto border border-indigo-100 hidden">
        <!-- Header -->
        <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold text-center text-indigo-700 mb-4 sm:mb-6 border-b-2 border-indigo-200 pb-2 sm:pb-4">
            EveXa Income-Expense Tracker
        </h1>

        <!-- Mobile App-like Banner Section -->
        <div id="bannerCarousel" class="relative w-full overflow-hidden rounded-xl shadow-md mb-6 sm:mb-8 h-32 sm:h-40 md:h-56 bg-indigo-200 glass-effect">
            <div class="carousel-inner h-full flex transition-transform duration-500 ease-in-out">
                <div class="carousel-item active w-full flex-shrink-0 bg-gradient-to-r from-indigo-500 to-purple-600 text-white flex items-center justify-center text-center p-3 sm:p-4 rounded-xl">
                    <p class="text-lg sm:text-xl md:text-3xl font-bold">Manage Your Money Smartly!</p>
                </div>
                <div class="carousel-item w-full flex-shrink-0 bg-gradient-to-r from-green-500 to-blue-600 text-white flex items-center justify-center text-center p-3 sm:p-4 rounded-xl">
                    <p class="text-lg sm:text-xl md:text-3xl font-bold">Track Needs vs. Wants!</p>
                </div>
                <div class="carousel-item w-full flex-shrink-0 bg-gradient-to-r from-yellow-500 to-orange-600 text-white flex items-center justify-center text-center p-3 sm:p-4 rounded-xl">
                    <p class="text-lg sm:text-xl md:text-3xl font-bold">Achieve Your Savings Goals!</p>
                </div>
            </div>
            <div class="absolute bottom-2 left-0 right-0 flex justify-center space-x-2">
                <span class="carousel-dot active w-2.5 h-2.5 bg-white opacity-70 rounded-full cursor-pointer"></span>
                <span class="carousel-dot w-2.5 h-2.5 bg-white opacity-40 rounded-full cursor-pointer"></span>
                <span class="carousel-dot w-2.5 h-2.5 bg-white opacity-40 rounded-full cursor-pointer"></span>
            </div>
        </div>

        <!-- Summary Section -->
        <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4 mb-6 sm:mb-8">
            <div class="bg-gradient-to-r from-green-500 to-green-600 text-white p-3 sm:p-4 rounded-xl shadow-md text-center">
                <p class="text-xs sm:text-sm uppercase opacity-90">Total Income</p>
                <p id="totalIncome" class="text-xl sm:text-2xl font-bold">‚Çπ0.00</p>
            </div>
            <div class="bg-gradient-to-r from-red-500 to-red-600 text-white p-3 sm:p-4 rounded-xl shadow-md text-center">
                <p class="text-xs sm:text-sm uppercase opacity-90">Total Expense</p>
                <p id="totalExpense" class="text-xl sm:text-2xl font-bold">‚Çπ0.00</p>
            </div>
            <div class="bg-gradient-to-r from-blue-500 to-blue-600 text-white p-3 sm:p-4 rounded-xl shadow-md text-center">
                <p class="text-xs sm:text-sm uppercase opacity-90">Balance</p>
                <p id="balance" class="text-xl sm:text-2xl font-bold">‚Çπ0.00</p>
            </div>
            <div class="bg-gradient-to-r from-purple-500 to-purple-600 text-white p-3 sm:p-4 rounded-xl shadow-md text-center">
                <p class="text-xs sm:text-sm uppercase opacity-90">Savings</p>
                <p id="totalSavings" class="text-xl sm:text-2xl font-bold">‚Çπ0.00</p>
            </div>
        </div>

        <!-- Savings Goals Section (Advanced Feature) -->
        <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner mb-6 sm:mb-8 border border-green-200">
            <h2 class="text-lg sm:text-xl font-semibold text-green-700 mb-3 sm:mb-4 border-b border-green-200 pb-1 sm:pb-2 flex items-center justify-center text-center">üéØ Savings Goals</h2>
            <div class="flex flex-col md:flex-row items-center gap-4">
                <div class="flex-grow w-full">
                    <label for="savingsGoalInput" class="block text-green-700 font-semibold mb-2 text-sm sm:text-base">Set Your Goal Amount (‚Çπ):</label>
                    <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2"> <!-- Added flex-col and flex-wrap for mobile responsiveness -->
                        <div class="flex items-center w-full sm:w-auto flex-grow">
                            <span class="text-green-600 text-lg sm:text-xl font-bold flex-shrink-0 mr-1">‚Çπ</span>
                            <input type="number" id="savingsGoalInput" placeholder="e.g., 100000"
                                   class="flex-grow p-2 sm:p-3 rounded-lg border border-green-300 focus:ring-2 focus:ring-green-400 focus:border-transparent text-base sm:text-lg text-green-800 bg-white/60 min-w-0">
                        </div>
                        <button id="setSavingsGoalBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 sm:py-3 sm:px-4 rounded-lg shadow-md transition duration-200 ease-in-out w-full sm:w-auto text-sm sm:text-base">
                            Set Goal
                        </button>
                    </div>
                </div>
                <div class="text-center p-3 sm:p-4 rounded-lg bg-green-100/70 border border-green-300 text-green-800 text-base font-medium shadow-sm w-full md:w-auto md:min-w-[200px] flex flex-col justify-center items-center glass-effect">
                    <p class="text-sm">Current Progress:</p>
                    <p id="savingsProgressDisplay" class="text-xl sm:text-2xl font-bold">‚Çπ0.00 / ‚Çπ0.00</p>
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                        <div id="savingsProgressBar" class="bg-green-600 h-2.5 rounded-full" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Committed Needs Section -->
        <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner mb-6 sm:mb-8 flex flex-col md:flex-row items-center justify-between gap-3 sm:gap-4 border border-blue-200">
            <div class="flex-grow text-center md:text-left">
                <p class="text-base sm:text-lg font-semibold mb-1 flex items-center justify-center md:justify-start">
                    <span class="mr-2 text-xl">üí∏</span> Committed Needs this month:
                </p>
                <p id="committedNeedsDisplay" class="text-2xl sm:text-3xl font-bold text-blue-800">‚Çπ0.00</p>
            </div>
            <div class="flex flex-col items-center md:items-end w-full md:w-auto">
                <p id="committedNeedsFeedback" class="text-blue-600 text-xs sm:text-sm italic mb-2 text-center md:text-right">
                    (Includes recurring payments like EMI, loans, and rent for this month.)
                </p>
                <button id="viewMoreCommittedNeedsBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                    View More
                </button>
            </div>
        </div>

        <!-- Budget & Feedback Section -->
        <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner mb-6 sm:mb-8 flex flex-col md:flex-row items-center justify-between gap-3 sm:gap-4">
            <div class="flex-grow w-full">
                <label for="monthlyBudget" class="block text-indigo-700 text-base sm:text-lg font-semibold mb-2">Monthly Budget (Wants):</label>
                <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2"> <!-- Added flex-col for responsiveness -->
                    <div class="flex items-center w-full sm:w-auto flex-grow">
                        <span class="text-indigo-600 text-lg sm:text-xl font-bold flex-shrink-0 mr-1">‚Çπ</span>
                        <input type="number" id="monthlyBudget" placeholder="e.g., 5000"
                               class="flex-grow p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 min-w-0 bg-white/60">
                    </div>
                    <button id="setBudgetBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-3 sm:py-3 sm:px-4 rounded-lg shadow-md transition duration-200 ease-in-out w-full sm:w-auto text-sm sm:text-base">
                        Set
                    </button>
                </div>
            </div>
            <div id="feedbackBox" class="section-glass-effect text-center p-3 sm:p-4 rounded-lg border border-indigo-300 text-indigo-800 text-base font-medium shadow-sm w-full md:w-auto md:min-w-[200px]">
                <p class="text-xl sm:text-2xl mb-1" id="feedbackEmoji">ü§î</p>
                <p id="feedbackText" class="text-sm sm:text-base">Set your budget!</p>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 mb-6 sm:mb-8">
            <button id="addEntryBtn"
                    class="w-full sm:w-1/2 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 sm:py-4 px-4 sm:px-6 rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:scale-105 text-lg sm:text-xl">
                ‚ûï Add New Entry
            </button>
            <button id="addRecurringEntryBtn"
                    class="w-full sm:w-1/2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 sm:py-4 px-4 sm:px-6 rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:scale-105 text-lg sm:text-xl">
                üîÑ Add Recurring Entry
            </button>
        </div>

        <!-- Scheduled Entries Section (Now on main page) -->
        <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner border border-purple-200 mb-6 sm:mb-8">
            <h2 class="text-xl sm:text-2xl font-semibold text-purple-700 mb-3 sm:mb-4 border-b border-purple-200 pb-1 sm:pb-2 text-center">All Scheduled Entries</h2>
            <div id="recurringList" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                <p class="text-center text-purple-500 italic text-sm">No recurring entries scheduled.</p>
            </div>
        </div>


        <!-- Transaction List & Chart Section -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
            <!-- Transaction List -->
            <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner border border-indigo-200">
                <h2 class="text-xl sm:text-2xl font-semibold text-indigo-700 mb-3 sm:mb-4 border-b border-indigo-200 pb-1 sm:pb-2 text-center">Recent Transactions</h2>
                <div class="mb-4 flex flex-col gap-2 sm:gap-4">
                    <!-- Top row: Select and Month Input -->
                    <div class="flex flex-col sm:flex-row sm:flex-nowrap gap-2 sm:gap-4 items-center justify-between">
                        <select id="filterDetailedCategory" class="w-full sm:flex-1 p-2 rounded-lg border border-indigo-300 text-indigo-800 focus:ring-2 focus:ring-indigo-400 bg-white/60 text-sm sm:text-base">
                            <option value="All">All Categories</option>
                            <option value="Food">Food</option>
                            <option value="Travel">Travel</option>
                            <option value="Utilities">Utilities</option>
                            <option value="Rent">Rent</option>
                            <option value="Shopping">Shopping</option>
                            <option value="Entertainment">Entertainment</option>
                            <option value="Education">Education</option>
                            <option value="Healthcare">Healthcare</option>
                            <option value="Transport">Transport</option>
                            <option value="Other">Other</option>
                            <option value="Income">Income</option>
                            <option value="Saving">Saving</option>
                            <option value="Debt">Debt</option>
                        </select>
                        <input type="month" id="filterMonth" class="w-full sm:flex-1 p-2 rounded-lg border border-indigo-300 text-indigo-800 focus:ring-2 focus:ring-indigo-400 bg-white/60 text-sm sm:text-base">
                    </div>
                    <!-- Bottom row: Export Buttons -->
                    <div class="flex flex-col sm:flex-row gap-2 sm:gap-4 justify-end items-center">
                        <button id="exportCsvBtn" class="w-full sm:w-auto flex-shrink-0 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                            Export CSV
                        </button>
                        <button id="exportPdfBtn" class="w-full sm:w-auto flex-shrink-0 bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                            Export PDF
                        </button>
                    </div>
                </div>
                <div id="transactionList" class="space-y-2 max-h-80 overflow-y-auto pr-2">
                    <!-- Transactions will be loaded here -->
                    <p class="text-center text-indigo-500 italic text-sm text-wrap">No transactions yet. Add one!</p>
                </div>
            </div>

            <!-- Visual Needs vs Wants Chart -->
            <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner border border-indigo-200 flex flex-col items-center justify-center">
                <h2 class="text-xl sm:text-2xl font-semibold text-indigo-700 mb-3 sm:mb-4 border-b border-indigo-200 pb-1 sm:pb-2 w-full text-center">Spending Breakdown</h2>
                <div class="relative w-full max-w-xs sm:max-w-sm md:max-w-md mx-auto aspect-square"> <!-- Adjusted max-width for mobile chart -->
                    <canvas id="spendingChart"></canvas>
                </div>
                <p id="chartStatus" class="text-center text-indigo-500 italic mt-3 sm:mt-4 text-sm text-wrap">Add expenses to see the chart.</p>
            </div>
        </div>

        <!-- Trusted Badges Carousel (Advanced Feature) -->
        <div class="section-glass-effect p-4 sm:p-6 rounded-xl shadow-inner border border-blue-200 mt-6 sm:mt-8 mb-6 sm:mb-8">
            <h2 class="text-xl sm:text-2xl font-semibold text-blue-700 mb-3 sm:mb-4 border-b border-blue-200 pb-1 sm:pb-2 text-center">Trusted Badges</h2>
            <div id="trustedBrandsCarousel" class="relative w-full overflow-hidden h-14 flex items-center justify-center"> <!-- Further reduced height -->
                <div class="carousel-inner h-full flex transition-transform duration-500 ease-in-out">
                    <div class="carousel-item active w-full flex-shrink-0 flex items-center justify-center">
                        <div class="bg-green-500 text-white px-3 py-1.5 rounded-lg shadow-md text-sm font-bold glass-effect">Verified ‚úÖ</div> <!-- Further smaller padding, text -->
                    </div>
                    <div class="carousel-item w-full flex-shrink-0 flex items-center justify-center">
                        <div class="bg-blue-500 text-white px-3 py-1.5 rounded-lg shadow-md text-sm font-bold glass-effect">Secure üîí</div> <!-- Further smaller padding, text -->
                    </div>
                    <div class="carousel-item w-full flex-shrink-0 flex items-center justify-center">
                        <div class="bg-yellow-500 text-white px-3 py-1.5 rounded-lg shadow-md text-sm font-bold glass-effect">Certified ‚≠ê</div> <!-- Further smaller padding, text -->
                    </div>
                    <div class="carousel-item w-full flex-shrink-0 flex items-center justify-center">
                        <div class="bg-purple-500 text-white px-3 py-1.5 rounded-lg shadow-md text-sm font-bold glass-effect">Private üõ°Ô∏è</div> <!-- Further smaller padding, text -->
                    </div>
                </div>
                <div class="absolute bottom-0 left-0 right-0 flex justify-center space-x-2">
                    <span class="carousel-dot-brands active w-2 h-2 bg-gray-600 opacity-70 rounded-full cursor-pointer"></span>
                    <span class="carousel-dot-brands w-2 h-2 bg-gray-600 opacity-40 rounded-full cursor-pointer"></span>
                    <span class="carousel-dot-brands w-2 h-2 bg-gray-600 opacity-40 rounded-full cursor-pointer"></span>
                    <span class="carousel-dot-brands w-2 h-2 bg-gray-600 opacity-40 rounded-full cursor-pointer"></span>
                </div>
            </div>
        </div>

        <!-- Ads Section (Placeholder) -->
        <div class="w-full max-w-4xl mx-auto mt-6 sm:mt-8 p-4 sm:p-6 bg-gray-100/70 rounded-xl shadow-inner border border-gray-200 text-center text-gray-700 text-base sm:text-lg italic glass-effect">
            <p class="mb-2">Your ad here!</p>
            <p class="text-xs sm:text-sm">Support us by considering our partners.</p>
            <div class="mt-3 sm:mt-4 bg-gray-200/50 h-20 sm:h-24 rounded-lg flex items-center justify-center text-gray-500 backdrop-blur-sm">
                [Advertisement Banner - 728x90 or 300x250 adaptive]
            </div>
        </div>

    </div>

    <!-- Add Entry Modal -->
    <div id="entryModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-glass-effect rounded-2xl shadow-xl p-4 sm:p-6 w-full max-w-lg transform transition-all duration-300 scale-95 opacity-0" id="modalContent">
            <h2 class="text-xl sm:text-2xl font-bold text-indigo-700 mb-4 sm:mb-6 border-b border-indigo-200 pb-2 sm:pb-3">Add New Entry</h2>
            <form id="entryForm" class="space-y-3 sm:space-y-4">
                <div>
                    <label for="entryType" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Type:</label>
                    <select id="entryType" class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60">
                        <option value="Expense">Expense</option>
                        <option value="Income">Income</option>
                    </select>
                </div>
                <div>
                    <label for="entryAmount" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Amount (‚Çπ):</label>
                    <input type="number" id="entryAmount" required placeholder="e.g., 1200"
                           class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60">
                </div>
                <div id="expenseCategoryGroup">
                    <label for="entryExpenseType" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Expense Type:</label>
                    <select id="entryExpenseType"
                            class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60">
                        <option value="">Select Expense Type</option>
                        <option value="Need">Need</option>
                        <option value="Want">Want</option>
                        <option value="Saving">Saving</option>
                        <option value="Debt">Debt</option>
                    </select>
                </div>
                <div id="detailedCategoryGroup">
                    <label for="entryDetailedCategory" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Detailed Category:</label>
                    <select id="entryDetailedCategory"
                            class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60">
                        <option value="">Select Detailed Category</option>
                        <option value="Food">Food</option>
                        <option value="Travel">Travel</option>
                        <option value="Utilities">Utilities</option>
                        <option value="Rent">Rent</option>
                        <option value="Shopping">Shopping</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Education">Education</option>
                        <option value="Healthcare">Healthcare</option>
                        <option value="Transport">Transport</option>
                        <option value="Other">Other</option>
                        <!-- Custom categories will be appended here by JS -->
                    </select>

                    <div class="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
                        <p class="font-semibold text-indigo-700 mb-2 text-sm sm:text-base">Manage Custom Categories:</p>
                        <div class="flex items-center gap-2 mb-3">
                            <input type="text" id="newCustomCategoryInput" placeholder="Add new category"
                                   class="flex-grow p-1.5 sm:p-2 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-sm sm:text-base text-indigo-800 bg-white/60">
                            <button type="button" id="addCustomCategoryBtn" class="bg-indigo-400 hover:bg-indigo-500 text-white font-semibold py-1.5 px-2.5 sm:py-2 sm:px-3 rounded-lg shadow-sm transition duration-200 ease-in-out text-xs sm:text-sm">
                                Add
                            </button>
                        </div>
                        <div id="customCategoryList" class="max-h-24 overflow-y-auto space-y-1 pr-1 text-sm">
                            <!-- Custom categories will be listed here dynamically -->
                        </div>
                    </div>
                </div>
                <div>
                    <label for="entryDate" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Date:</label>
                    <input type="date" id="entryDate" required
                           class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60">
                </div>
                <div>
                    <label for="entryNote" class="block text-indigo-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Note (Optional):</label>
                    <textarea id="entryNote" rows="3" placeholder="e.g., Groceries for the week"
                              class="w-full p-2 sm:p-3 rounded-lg border border-indigo-300 focus:ring-2 focus:ring-indigo-400 focus:border-transparent text-base sm:text-lg text-indigo-800 bg-white/60"></textarea>
                </div>
                <div class="flex justify-end gap-2 sm:gap-3 pt-3 sm:pt-4">
                    <button type="button" id="cancelEntryBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                        Cancel
                    </button>
                    <button type="submit"
                            class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                        Add Entry
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Add Recurring Entry Modal (Now ONLY for adding new recurring entries) -->
    <div id="recurringEntryModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-glass-effect rounded-2xl shadow-xl p-4 sm:p-6 w-full max-w-lg transform transition-all duration-300 scale-95 opacity-0" id="recurringModalContent">
            <h2 class="text-xl sm:text-2xl font-bold text-purple-700 mb-4 sm:mb-6 border-b border-purple-200 pb-2 sm:pb-3">Schedule New Recurring Entry</h2>
            <form id="recurringEntryForm" class="space-y-3 sm:space-y-4">
                <div>
                    <label for="recurringAmount" class="block text-purple-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Amount (‚Çπ):</label>
                    <input type="number" id="recurringAmount" required placeholder="e.g., 7000"
                           class="w-full p-2 sm:p-3 rounded-lg border border-purple-300 focus:ring-2 focus:ring-purple-400 focus:border-transparent text-base sm:text-lg text-purple-800 bg-white/60">
                </div>
                <div>
                    <label for="recurringDetailedCategory" class="block text-purple-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Detailed Category:</label>
                    <select id="recurringDetailedCategory" required
                            class="w-full p-2 sm:p-3 rounded-lg border border-purple-300 focus:ring-2 focus:ring-purple-400 focus:border-transparent text-base sm:text-lg text-purple-800 bg-white/60">
                        <option value="">Select Detailed Category</option>
                        <option value="Food">Food</option>
                        <option value="Travel">Travel</option>
                        <option value="Utilities">Utilities</option>
                        <option value="Rent">Rent</option>
                        <option value="Shopping">Shopping</option>
                        <option value="Entertainment">Entertainment</option>
                        <option value="Education">Education</option>
                        <option value="Healthcare">Healthcare</option>
                        <option value="Transport">Transport</option>
                        <option value="Other">Other</option>
                        <!-- Custom categories will be appended here by JS -->
                    </select>
                </div>
                <div>
                    <label for="recurringExpenseType" class="block text-purple-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Expense Type:</label>
                    <select id="recurringExpenseType" required
                            class="w-full p-2 sm:p-3 rounded-lg border border-purple-300 focus:ring-2 focus:ring-purple-400 focus:border-transparent text-base sm:text-lg text-purple-800 bg-white/60">
                        <option value="">Select Expense Type</option>
                        <option value="Need">Need</option>
                        <option value="Want">Want</option>
                    </select>
                </div>
                <div>
                    <label for="recurringStartDate" class="block text-purple-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Start Date:</label>
                    <input type="date" id="recurringStartDate" required
                           class="w-full p-2 sm:p-3 rounded-lg border border-purple-300 focus:ring-2 focus:ring-purple-400 focus:border-transparent text-base sm:text-lg text-purple-800 bg-white/60">
                </div>
                <div>
                    <label for="recurrenceInterval" class="block text-purple-700 font-semibold mb-1 sm:mb-2 text-sm sm:text-base">Recurrence Interval:</label>
                    <select id="recurrenceInterval" required
                            class="w-full p-2 sm:p-3 rounded-lg border border-purple-300 focus:ring-2 focus:ring-purple-400 focus:border-transparent text-base sm:text-lg text-purple-800 bg-white/60">
                        <option value="monthly">Monthly</option>
                        <option value="weekly">Weekly</option>
                    </select>
                </div>
                <div class="flex justify-end gap-2 sm:gap-3 pt-3 sm:pt-4">
                    <button type="button" id="cancelRecurringBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                        Cancel
                    </button>
                    <button type="submit"
                            class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                        Schedule
                    </button>
                </div>
            </form>
            <!-- No recurring list here anymore, it's on the main page -->
        </div>
    </div>

    <!-- Committed Needs Detail Modal -->
    <div id="committedNeedsDetailModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 hidden">
        <div class="modal-glass-effect rounded-2xl shadow-xl p-4 sm:p-6 w-full max-w-lg transform transition-all duration-300 scale-95 opacity-0" id="committedNeedsDetailModalContent">
            <h2 class="text-xl sm:text-2xl font-bold text-blue-700 mb-4 sm:mb-6 border-b border-blue-200 pb-2 sm:pb-3">Committed Needs This Month</h2>
            <div id="committedNeedsDetailList" class="space-y-2 max-h-80 overflow-y-auto pr-2">
                <!-- Committed needs details will be loaded here -->
                <p class="text-center text-blue-500 italic text-sm">No committed needs scheduled for this month.</p>
            </div>
            <div class="flex justify-end gap-2 sm:gap-3 pt-3 sm:pt-4">
                <button type="button" id="undoLastPaidBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base hidden">
                    Undo Last Paid
                </button>
                <button type="button" id="closeCommittedNeedsDetailBtn"
                        class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 sm:py-3 px-4 sm:px-6 rounded-lg shadow-md transition duration-200 ease-in-out text-sm sm:text-base">
                    Close
                </button>
            </div>
        </div>
    </div>


    <!-- Privacy Lock Modal -->
    <div id="privacyLockModal" class="fixed inset-0 bg-indigo-800 bg-opacity-95 flex flex-col items-center justify-center p-4 z-[100] hidden">
        <div class="modal-glass-effect rounded-2xl shadow-xl p-5 sm:p-6 w-full max-w-sm text-center transform transition-all duration-300 scale-95 opacity-0" id="lockModalContent">
            <h2 id="lockModalTitle" class="text-2xl sm:text-3xl font-bold text-indigo-700 mb-5 sm:mb-6">üîí Enter PIN</h2>
            <div class="mb-5 sm:mb-6">
                <input type="password" id="pinInput" maxlength="4" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                       class="w-full p-3 sm:p-4 text-center text-3xl sm:text-4xl tracking-[0.5em] rounded-lg border-2 border-indigo-300 focus:ring-4 focus:ring-indigo-400 focus:border-transparent font-mono text-indigo-800 bg-white/60">
                <p id="pinError" class="text-red-500 text-xs sm:text-sm mt-2 hidden">Invalid PIN. Please try again.</p>
                <p id="lockoutMessage" class="text-red-600 font-semibold mt-2 hidden text-xs sm:text-sm">Too many failed attempts. Try again in <span id="lockoutTimer"></span> seconds.</p>
            </div>
            <div class="flex flex-col gap-2 sm:gap-3">
                <button id="unlockBtn"
                        class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 sm:py-4 rounded-xl shadow-lg transition duration-300 ease-in-out transform hover:scale-105 text-base sm:text-lg">
                    Unlock
                </button>
                <button id="setNewPinBtn"
                        class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2.5 sm:py-3 rounded-xl shadow-md transition duration-200 ease-in-out text-sm sm:text-base hidden">
                    Set New PIN
                </button>
                <button id="forgotPinBtn"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2.5 sm:py-3 rounded-xl shadow-md transition duration-300 ease-in-out text-sm sm:text-base">
                    Forgot PIN (Resets All Data)
                </button>
                <button id="resetPinBtn"
                        class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2.5 sm:py-3 rounded-xl shadow-md transition duration-300 ease-in-out text-sm sm:text-base hidden">
                    Reset All Data (Deletes All & PIN)
                </button>
            </div>
        </div>
    </div>


    <!-- Custom Alert/Message Box -->
    <div id="messageBox" class="fixed bottom-4 right-4 bg-green-500 text-white p-3 rounded-lg shadow-xl hidden transition-all duration-300 transform translate-y-full opacity-0 z-50 text-sm">
        <p id="messageText"></p>
    </div>

    <script>
        /**
         * SECTION: DOM Element References
         * Contains references to all necessary HTML elements by their IDs.
         */
        const appLoader = document.getElementById('appLoader');
        const mainAppContent = document.getElementById('mainAppContent');
        const addEntryBtn = document.getElementById('addEntryBtn');
        const entryModal = document.getElementById('entryModal');
        const modalContent = document.getElementById('modalContent');
        const cancelEntryBtn = document.getElementById('cancelEntryBtn');
        const entryForm = document.getElementById('entryForm');
        const entryType = document.getElementById('entryType');
        const entryAmount = document.getElementById('entryAmount');
        const expenseCategoryGroup = document.getElementById('expenseCategoryGroup');
        const entryExpenseType = document.getElementById('entryExpenseType');
        const detailedCategoryGroup = document.getElementById('detailedCategoryGroup');
        const entryDetailedCategory = document.getElementById('entryDetailedCategory');
        const entryDate = document.getElementById('entryDate');
        const entryNote = document.getElementById('entryNote');
        const newCustomCategoryInput = document.getElementById('newCustomCategoryInput');
        const addCustomCategoryBtn = document.getElementById('addCustomCategoryBtn');
        const customCategoryList = document.getElementById('customCategoryList'); // New element reference

        const totalIncomeEl = document.getElementById('totalIncome');
        const totalExpenseEl = document.getElementById('totalExpense');
        const balanceEl = document.getElementById('balance');
        const totalSavingsEl = document.getElementById('totalSavings');
        const transactionListEl = document.getElementById('transactionList');
        const filterDetailedCategoryEl = document.getElementById('filterDetailedCategory');
        const filterMonthEl = document.getElementById('filterMonth');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn');

        const monthlyBudgetEl = document.getElementById('monthlyBudget');
        const setBudgetBtn = document.getElementById('setBudgetBtn');
        const feedbackEmojiEl = document.getElementById('feedbackEmoji');
        const feedbackTextEl = document.getElementById('feedbackText');
        const committedNeedsDisplayEl = document.getElementById('committedNeedsDisplay');
        const committedNeedsFeedbackEl = document.getElementById('committedNeedsFeedback');
        // Corrected line:
        const viewMoreCommittedNeedsBtn = document.getElementById('viewMoreCommittedNeedsBtn');

        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const chartStatusEl = document.getElementById('chartStatus');

        // Recurring Entry Elements
        const addRecurringEntryBtn = document.getElementById('addRecurringEntryBtn');
        const recurringEntryModal = document.getElementById('recurringEntryModal');
        const recurringModalContent = document.getElementById('recurringModalContent');
        const cancelRecurringBtn = document.getElementById('cancelRecurringBtn');
        const recurringEntryForm = document.getElementById('recurringEntryForm');
        const recurringAmount = document.getElementById('recurringAmount');
        const recurringDetailedCategory = document.getElementById('recurringDetailedCategory');
        const recurringExpenseType = document.getElementById('recurringExpenseType');
        const recurringStartDate = document.getElementById('recurringStartDate');
        const recurrenceInterval = document.getElementById('recurrenceInterval');
        const recurringListEl = document.getElementById('recurringList');

        // Committed Needs Detail Modal Elements
        const committedNeedsDetailModal = document.getElementById('committedNeedsDetailModal');
        const committedNeedsDetailModalContent = document.getElementById('committedNeedsDetailModalContent');
        const committedNeedsDetailList = document.getElementById('committedNeedsDetailList');
        const closeCommittedNeedsDetailBtn = document.getElementById('closeCommittedNeedsDetailBtn');
        const undoLastPaidBtn = document.getElementById('undoLastPaidBtn');

        // Privacy Lock Elements
        const privacyLockModal = document.getElementById('privacyLockModal');
        const lockModalContent = document.getElementById('lockModalContent');
        const lockModalTitle = document.getElementById('lockModalTitle');
        const pinInput = document.getElementById('pinInput');
        const pinError = document.getElementById('pinError');
        const unlockBtn = document.getElementById('unlockBtn');
        const setNewPinBtn = document.getElementById('setNewPinBtn');
        const resetPinBtn = document.getElementById('resetPinBtn');
        const forgotPinBtn = document.getElementById('forgotPinBtn'); 
        const lockoutMessage = document.getElementById('lockoutMessage');
        const lockoutTimerDisplay = document.getElementById('lockoutTimer');

        // Savings Goals Elements
        const savingsGoalInput = document.getElementById('savingsGoalInput');
        const setSavingsGoalBtn = document.getElementById('setSavingsGoalBtn');
        const savingsProgressDisplay = document.getElementById('savingsProgressDisplay');
        const savingsProgressBar = document.getElementById('savingsProgressBar');

        /**
         * SECTION: Global Variables
         * Stores application data and state.
         */
        let transactions = []; // Array to store all transactions
        let monthlyBudget = 0; // User's monthly budget for 'Wants'
        let storedPIN = null; // Stored PIN from localStorage
        let recurringTransactions = []; // Array to store recurring transaction schedules
        let customCategories = []; // Array to store user-defined custom categories
        let savingsGoal = 0; // User's total savings goal amount
        let currentSavingsProgress = 0; // Current accumulated savings

        // Chart.js instance
        let spendingChart = null;

        // Security Feature Variables
        const MAX_FAILED_ATTEMPTS = 3;
        const LOCKOUT_DURATION_SECONDS = 60; // 1 minute
        let failedAttempts = parseInt(localStorage.getItem('failedAttempts')) || 0;
        let lockoutEndTime = parseInt(localStorage.getItem('lockoutEndTime')) || 0;
        let lockoutIntervalId = null;

        // Idle Timeout
        const IDLE_TIMEOUT_MINUTES = 5; // 5 minutes
        const IDLE_TIMEOUT_MS = IDLE_TIMEOUT_MINUTES * 60 * 1000;
        let idleTimeoutTimerId = null;
        let lastActivityTime = Date.now();

        // Undo Functionality
        let lastUndoAction = null;

        // Carousel Intervals
        let bannerCarouselInterval = null;
        let brandsCarouselInterval = null;

        /**
         * SECTION: LocalStorage Utility Functions
         * Handles saving and loading data to/from localStorage with error handling.
         */
        const saveTransactions = () => {
            try {
                localStorage.setItem('transactions', JSON.stringify(transactions));
            } catch (error) {
                console.error('Error saving transactions to localStorage:', error);
                showMessage('Failed to save transactions. Your browser storage might be full or blocked.', 'error');
            }
        };

        const loadTransactions = () => {
            try {
                const storedTransactions = localStorage.getItem('transactions');
                if (storedTransactions) {
                    transactions = JSON.parse(storedTransactions);
                }
            } catch (error) {
                console.error('Error loading transactions from localStorage:', error);
                showMessage('Failed to load transactions. Your data might be corrupted or inaccessible.', 'error');
                transactions = []; // Reset to empty to prevent further issues
            }
        };

        const saveBudget = () => {
            try {
                localStorage.setItem('monthlyBudget', monthlyBudget);
            } catch (error) {
                console.error('Error saving budget to localStorage:', error);
                showMessage('Failed to save budget settings.', 'error');
            }
        };

        const loadBudget = () => {
            try {
                const storedBudget = localStorage.getItem('monthlyBudget');
                if (storedBudget) {
                    monthlyBudget = parseFloat(storedBudget);
                    monthlyBudgetEl.value = monthlyBudget;
                }
            } catch (error) {
                console.error('Error loading budget from localStorage:', error);
                showMessage('Failed to load budget settings.', 'error');
            }
        };

        const savePIN = (pin) => {
            try {
                localStorage.setItem('appPIN', pin);
                storedPIN = pin;
            } catch (error) {
                console.error('Error saving PIN to localStorage:', error);
                showMessage('Failed to save PIN. Please try again.', 'error');
            }
        };

        const loadPIN = () => {
            try {
                storedPIN = localStorage.getItem('appPIN');
            } catch (error) {
                console.error('Error loading PIN from localStorage:', error);
                showMessage('Failed to load PIN. Security features might not work correctly.', 'error');
            }
        };

        const clearPIN = () => {
            try {
                localStorage.removeItem('appPIN');
                storedPIN = null;
            } catch (error) {
                console.error('Error clearing PIN from localStorage:', error);
                showMessage('Failed to clear PIN.', 'error');
            }
        };

        const saveRecurringTransactions = () => {
            try {
                localStorage.setItem('recurringTransactions', JSON.stringify(recurringTransactions));
            } catch (error) {
                console.error('Error saving recurring transactions to localStorage:', error);
                showMessage('Failed to save recurring entries.', 'error');
            }
        };

        const loadRecurringTransactions = () => {
            try {
                const storedRecurringTransactions = localStorage.getItem('recurringTransactions');
                if (storedRecurringTransactions) {
                    recurringTransactions = JSON.parse(storedRecurringTransactions);
                }
            } catch (error) {
                console.error('Error loading recurring transactions from localStorage:', error);
                showMessage('Failed to load recurring entries. Some scheduled items might be missing.', 'error');
                recurringTransactions = [];
            }
        };

        const saveCustomCategories = () => {
            try {
                localStorage.setItem('customCategories', JSON.stringify(customCategories));
            } catch (error) {
                console.error('Error saving custom categories to localStorage:', error);
                showMessage('Failed to save custom categories.', 'error');
            }
        };

        const loadCustomCategories = () => {
            try {
                const storedCategories = localStorage.getItem('customCategories');
                if (storedCategories) {
                    customCategories = JSON.parse(storedCategories);
                }
            } catch (error) {
                console.error('Error loading custom categories from localStorage:', error);
                showMessage('Failed to load custom categories.', 'error');
                customCategories = [];
            }
        };

        const saveSavingsGoal = () => {
            try {
                localStorage.setItem('savingsGoal', savingsGoal);
            } catch (error) {
                console.error('Error saving savings goal to localStorage:', error);
                showMessage('Failed to save your savings goal.', 'error');
            }
        };

        const loadSavingsGoal = () => {
            try {
                const storedGoal = localStorage.getItem('savingsGoal');
                if (storedGoal) {
                    savingsGoal = parseFloat(storedGoal);
                    savingsGoalInput.value = savingsGoal;
                }
            } catch (error) {
                console.error('Error loading savings goal from localStorage:', error);
                showMessage('Failed to load your savings goal.', 'error');
            }
        };

        /**
         * SECTION: UI Update Functions
         * Functions responsible for updating different parts of the user interface.
         */

        /**
         * Displays a temporary message box to the user.
         * @param {string} message - The message to display.
         * @param {'success'|'error'|'info'} type - The type of message (determines color).
         */
        const showMessage = (message, type = 'success') => {
            try {
                messageText.textContent = message;
                messageBox.className = `fixed bottom-4 right-4 p-3 rounded-lg shadow-xl transition-all duration-300 transform z-50 ${type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'} text-white text-sm`;
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('translate-y-full', 'opacity-0');
                    messageBox.addEventListener('transitionend', () => {
                        messageBox.classList.add('hidden');
                        messageBox.classList.remove('translate-y-full', 'opacity-0');
                    }, { once: true });
                }, 3000); // Message visible for 3 seconds
                messageBox.classList.remove('translate-y-full', 'opacity-0');
            } catch (error) {
                console.error('Error displaying message box:', error);
            }
        };

        /**
         * Populates the detailed category dropdowns (for both new entries and recurring entries)
         * including predefined and custom categories. Also renders the list of custom categories.
         */
        const populateCategoryDropdowns = () => {
            try {
                const defaultCategories = ['Food', 'Travel', 'Utilities', 'Rent', 'Shopping', 'Entertainment', 'Education', 'Healthcare', 'Transport', 'Other'];
                const allCategories = [...defaultCategories, ...customCategories.filter(cat => !defaultCategories.includes(cat))]; // Merge, unique

                const createOptions = (selectElement) => {
                    selectElement.innerHTML = ''; // Clear existing options
                    // Add "All" option for the filter dropdown specifically
                    if (selectElement.id === 'filterDetailedCategory') {
                        const allOption = document.createElement('option');
                        allOption.value = 'All';
                        allOption.textContent = 'All Categories';
                        selectElement.appendChild(allOption);
                    }
                    // Add 'Income', 'Saving', 'Debt' to filter dropdown
                    if (selectElement.id === 'filterDetailedCategory') {
                        ['Income', 'Saving', 'Debt'].forEach(specialCat => {
                            const option = document.createElement('option');
                            option.value = specialCat;
                            option.textContent = specialCat;
                            selectElement.appendChild(option);
                        });
                    }
                    // For entry/recurring, ensure "Select Detailed Category" is the first option
                    if (selectElement.id === 'entryDetailedCategory' || selectElement.id === 'recurringDetailedCategory') {
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = 'Select Detailed Category';
                        selectElement.appendChild(defaultOption);
                    }

                    allCategories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat;
                        option.textContent = cat;
                        selectElement.appendChild(option);
                    });
                };

                // Store current selections before repopulating
                const currentEntryDetailedCategory = entryDetailedCategory.value;
                const currentRecurringDetailedCategory = recurringDetailedCategory.value;
                const currentFilterCategory = filterDetailedCategoryEl.value;

                // Populate dropdowns
                createOptions(entryDetailedCategory);
                createOptions(recurringDetailedCategory);
                createOptions(filterDetailedCategoryEl);

                // Restore previous selections
                entryDetailedCategory.value = currentEntryDetailedCategory;
                recurringDetailedCategory.value = currentRecurringDetailedCategory;
                filterDetailedCategoryEl.value = currentFilterCategory;


                // --- Render custom category list in modal ---
                customCategoryList.innerHTML = ''; // Clear existing list items
                if (customCategories.length === 0) {
                    customCategoryList.innerHTML = '<p class="text-center text-gray-500 italic">No custom categories added.</p>';
                } else {
                    customCategories.forEach(cat => {
                        const catItem = document.createElement('div');
                        catItem.className = 'flex items-center justify-between bg-gray-100 rounded-md px-2 py-1 shadow-sm text-gray-700';
                        catItem.innerHTML = `
                            <span class="text-sm flex-grow truncate">${cat}</span>
                            <button type="button" data-category="${cat}" class="remove-custom-category-btn text-red-500 hover:text-red-700 ml-2 text-base p-0.5 rounded-full hover:bg-gray-200 transition-colors" title="Remove category">
                                &times;
                            </button>
                        `;
                        customCategoryList.appendChild(catItem);
                    });

                    // Add event listeners to new remove buttons
                    document.querySelectorAll('.remove-custom-category-btn').forEach(button => {
                        button.onclick = handleRemoveCustomCategory;
                    });
                }

            } catch (error) {
                console.error('Error populating category dropdowns and list:', error);
                showMessage('Failed to load categories.', 'error');
            }
        };

        /**
         * Renders the list of transactions based on current filters.
         */
        const renderTransactions = () => {
            try {
                transactionListEl.innerHTML = ''; // Clear existing list

                const selectedDetailedCategory = filterDetailedCategoryEl.value;
                const selectedMonth = filterMonthEl.value; // Format:YYYY-MM

                console.log('--- Debugging renderTransactions ---');
                console.log('Total transactions in global array:', transactions.length, transactions);
                console.log('Current Filter: Selected Category:', selectedDetailedCategory, 'Selected Month:', selectedMonth);


                // Filter transactions
                const filteredTransactions = transactions.filter(t => {
                    // Category filtering logic
                    const matchesCategory = selectedDetailedCategory === 'All' ||
                                            (t.type === 'Income' && selectedDetailedCategory === 'Income') ||
                                            (t.type === 'Expense' && t.detailedCategory === selectedDetailedCategory) ||
                                            (t.type === 'Expense' && t.expenseType === selectedDetailedCategory);

                    // Month filtering logic
                    const transactionMonth = new Date(t.date).toISOString().substring(0, 7); //YYYY-MM
                    const matchesMonth = !selectedMonth || transactionMonth === selectedMonth;

                    return matchesCategory && matchesMonth;
                }).sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort by date, newest first

                console.log('Filtered transactions count:', filteredTransactions.length);
                console.log('Filtered transactions (data used for rendering):', filteredTransactions);


                if (filteredTransactions.length === 0) {
                    transactionListEl.innerHTML = '<p class="text-center text-indigo-500 italic text-sm text-wrap">No transactions found for the selected filters.</p>';
                    return;
                }

                filteredTransactions.forEach(transaction => {
                    console.log('Rendering transaction:', transaction); // Log each transaction being rendered
                    let colorClass;
                    let prefix = '';
                    let displayCategory = transaction.detailedCategory || 'N/A'; // Default to N/A if not set

                    if (transaction.type === 'Income') {
                        colorClass = 'bg-green-100 border-green-300 text-green-800';
                        prefix = '+';
                        displayCategory = 'Income'; // Ensure "Income" is displayed for income type
                    } else { // Expense
                        switch (transaction.expenseType) { // Use expenseType for coloring
                            case 'Need':
                                colorClass = 'bg-blue-100 border-blue-300 text-blue-800';
                                break;
                            case 'Want':
                                colorClass = 'bg-red-100 border-red-300 text-red-800';
                                break;
                            case 'Saving':
                                colorClass = 'bg-purple-100 border-purple-300 text-purple-800';
                                break;
                            case 'Debt':
                                colorClass = 'bg-orange-100 border-orange-300 text-orange-800';
                                break;
                            default:
                                colorClass = 'bg-gray-100 border-gray-300 text-gray-800'; // Fallback for undefined expenseType
                        }
                        prefix = '-';
                        displayCategory = transaction.detailedCategory || 'Expense'; // Fallback for display
                    }

                    const transactionEl = document.createElement('div');
                    transactionEl.className = `flex justify-between items-center p-2 rounded-lg shadow-sm border ${colorClass}`;
                    transactionEl.innerHTML = `
                        <div class="flex-grow min-w-0">
                            <p class="font-semibold text-base truncate">${transaction.note || displayCategory}</p>
                            <p class="text-xs text-gray-600">${new Date(transaction.date).toLocaleDateString()} (${transaction.expenseType || transaction.type})</p>
                        </div>
                        <div class="flex items-center gap-1 flex-shrink-0">
                            <span class="font-bold text-lg">${prefix}‚Çπ${transaction.amount.toLocaleString('en-IN')}</span>
                            <button data-id="${transaction.id}" class="delete-btn text-gray-500 hover:text-red-600 text-base p-0.5 rounded-full hover:bg-gray-200 transition-colors">
                                &times;
                            </button>
                        </div>
                    `;
                    transactionListEl.appendChild(transactionEl);
                });

                // Add event listeners to delete buttons
                document.querySelectorAll('.delete-btn').forEach(button => {
                    button.onclick = (e) => {
                        try {
                            const idToDelete = e.target.dataset.id;
                            transactions = transactions.filter(t => t.id !== idToDelete);
                            saveTransactions();
                            updateUI();
                            showMessage('Entry deleted successfully!', 'success');
                        } catch (error) {
                            console.error('Error deleting transaction:', error);
                            showMessage('Failed to delete entry.', 'error');
                        }
                    };
                });
            } catch (error) {
                console.error('Error rendering transactions:', error);
                showMessage('Failed to display transactions.', 'error');
            }
        };

        /**
         * Calculates and updates the summary figures (Total Income, Total Expense, Balance, Total Savings).
         */
        const updateSummary = () => {
            try {
                let income = 0;
                let expense = 0;
                currentSavingsProgress = 0; // Reset for recalculation

                transactions.forEach(t => {
                    if (t.type === 'Income') {
                        income += t.amount;
                    } else if (t.type === 'Expense') {
                        expense += t.amount;
                        if (t.expenseType === 'Saving') { // Treat 'Saving' as an expense that contributes to savings balance
                            currentSavingsProgress += t.amount;
                        }
                    }
                });

                totalIncomeEl.textContent = `‚Çπ${income.toLocaleString('en-IN')}`;
                totalExpenseEl.textContent = `‚Çπ${expense.toLocaleString('en-IN')}`;
                balanceEl.textContent = `‚Çπ${(income - expense).toLocaleString('en-IN')}`;
                totalSavingsEl.textContent = `‚Çπ${currentSavingsProgress.toLocaleString('en-IN')}`; // Display actual savings accumulated
                updateSavingsGoalDisplay(); // Update savings goal progress bar
            } catch (error) {
                console.error('Error updating summary:', error);
                showMessage('Failed to update summary figures.', 'error');
            }
        };

        /**
         * Updates the spending chart (doughnut chart).
         */
        const updateChart = () => {
            try {
                // Predefined categories for chart, plus dynamically added custom ones
                const categoriesForChart = [...new Set(['Food', 'Travel', 'Utilities', 'Rent', 'Shopping', 'Entertainment', 'Education', 'Healthcare', 'Transport', 'Other', ...customCategories])];
                const expenseBreakdown = {};
                categoriesForChart.forEach(cat => expenseBreakdown[cat] = 0);

                const today = new Date();
                const currentMonthExpenses = transactions.filter(t => {
                    const transactionDate = new Date(t.date);
                    return t.type === 'Expense' &&
                           transactionDate.getMonth() === today.getMonth() &&
                           transactionDate.getFullYear() === today.getFullYear() &&
                           categoriesForChart.includes(t.detailedCategory);
                });

                currentMonthExpenses.forEach(t => {
                    expenseBreakdown[t.detailedCategory] += t.amount;
                });

                const chartLabels = [];
                const chartDataValues = [];
                const backgroundColors = [];

                // Define consistent colors for categories (add more if needed or use a color generation logic)
                const categoryColors = {
                    'Food': '#FBBF24', 'Travel': '#60A5FA', 'Utilities': '#A78BFA', 'Rent': '#34D399',
                    'Shopping': '#F87171', 'Entertainment': '#EC4899', 'Education': '#10B981',
                    'Healthcare': '#EF4444', 'Transport': '#8B5CF6', 'Other': '#9CA3AF'
                };
                // Assign a default color for custom categories if not already defined
                let customColorIndex = 0;
                const defaultColors = ['#4F46E5', '#DC2626', '#10B981', '#F59E0B', '#6366F1', '#EC4899', '#A855F7', '#EF4444'];


                for (const cat of categoriesForChart) {
                    if (expenseBreakdown[cat] > 0) {
                        chartLabels.push(cat);
                        chartDataValues.push(expenseBreakdown[cat]);
                        // Assign a specific color or a default from a rotating list
                        backgroundColors.push(categoryColors[cat] || defaultColors[customColorIndex % defaultColors.length]);
                        if (!categoryColors[cat]) { // Only advance index for custom colors
                            customColorIndex++;
                        }
                    }
                }

                if (chartDataValues.length === 0) {
                    chartStatusEl.textContent = 'No expenses this month yet. Add some to see the chart!';
                    if (spendingChart) {
                        spendingChart.destroy();
                        spendingChart = null;
                    }
                    return;
                } else {
                     chartStatusEl.textContent = '';
                }

                const chartData = {
                    labels: chartLabels,
                    datasets: [{
                        data: chartDataValues,
                        backgroundColor: backgroundColors,
                        hoverOffset: 8,
                        borderRadius: 8
                    }]
                };

                if (spendingChart) {
                    spendingChart.data = chartData;
                    spendingChart.update();
                } else {
                    const ctx = document.getElementById('spendingChart').getContext('2d');
                    spendingChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: chartData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        font: {
                                            size: 12, // Smaller font for mobile legend
                                            family: 'Inter'
                                        },
                                        color: '#4B5563'
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            let label = context.label || '';
                                            if (label) {
                                                label += ': ';
                                            }
                                            if (context.parsed !== null) {
                                                label += `‚Çπ${context.parsed.toLocaleString('en-IN')}`;
                                            }
                                            return label;
                                        },
                                        afterLabel: function(context) {
                                            const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                                            return `(${percentage}%)`;
                                        }
                                    },
                                    titleFont: { family: 'Inter', size: 14 }, // Smaller tooltip title
                                    bodyFont: { family: 'Inter', size: 12 }, // Smaller tooltip body
                                    padding: 10,
                                    borderRadius: 6,
                                    displayColors: true,
                                }
                            },
                            cutout: '70%',
                        }
                    });
                }
            } catch (error) {
                console.error('Error updating chart:', error);
                showMessage('Failed to render spending chart.', 'error');
            }
        };

        /**
         * Updates the budget feedback and smart alerts based on current spending.
         */
        const updateFeedback = () => {
            try {
                const today = new Date();
                const currentMonth = today.getMonth();
                const currentYear = today.getFullYear();

                // Calculate current month's wants
                const currentMonthWants = transactions.filter(t => {
                    const transactionDate = new Date(t.date);
                    return t.type === 'Expense' && t.expenseType === 'Want' &&
                           transactionDate.getMonth() === currentMonth &&
                           transactionDate.getFullYear() === currentYear;
                }).reduce((sum, t) => sum + t.amount, 0);

                // Calculate current month's committed needs from recurring transactions
                let currentMonthCommittedNeeds = 0;
                recurringTransactions.forEach(rec => {
                    const nextDue = new Date(rec.nextDueDate);
                    if (rec.expenseType === 'Need' &&
                        nextDue.getMonth() === currentMonth &&
                        nextDue.getFullYear() === currentYear) {
                        currentMonthCommittedNeeds += rec.amount;
                    }
                });

                // Update the committed needs display element
                committedNeedsDisplayEl.textContent = `‚Çπ${currentMonthCommittedNeeds.toLocaleString('en-IN')}`;

                let feedbackEmoji = 'ü§î';
                let feedbackText = '';

                // Initial feedback based on budget
                if (monthlyBudget > 0) {
                    const wantsPercentage = (currentMonthWants / monthlyBudget) * 100;

                    if (wantsPercentage >= 100) {
                        feedbackEmoji = 'üò±';
                        feedbackText = `üö® Over budget on wants by ‚Çπ${(currentMonthWants - monthlyBudget).toLocaleString('en-IN')}!`;
                    } else if (wantsPercentage >= 85) {
                        feedbackEmoji = 'üò¨';
                        feedbackText = `‚ö†Ô∏è You‚Äôve spent ${wantsPercentage.toFixed(0)}% of your wants budget!`;
                    } else if (wantsPercentage >= 50) {
                        feedbackEmoji = 'üëç';
                        feedbackText = 'On track with wants! Used ${wantsPercentage.toFixed(0)}% of budget.';
                    } else {
                        feedbackEmoji = 'üòá';
                        feedbackText = 'Great spending on wants!';
                    }
                } else {
                    feedbackText = 'Set your budget for "Wants" to get personalized feedback!';
                }

                // Basic Advice System (Example: Food/Shopping spending)
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(today.getDate() - 30);

                const recentFoodSpending = transactions.filter(t => {
                    const transactionDate = new Date(t.date);
                    return t.type === 'Expense' && t.detailedCategory === 'Food' && transactionDate >= thirtyDaysAgo;
                }).reduce((sum, t) => sum + t.amount, 0);

                const recentShoppingSpending = transactions.filter(t => {
                    const transactionDate = new Date(t.date);
                    return t.type === 'Expense' && t.detailedCategory === 'Shopping' && transactionDate >= thirtyDaysAgo;
                }).reduce((sum, t) => sum + t.amount, 0);

                if (recentFoodSpending > 5000 && monthlyBudget > 0) { // Example threshold
                    feedbackText += `\nüí° You spent ‚Çπ${recentFoodSpending.toLocaleString('en-IN')} on Food recently. Try cooking more!`;
                }
                if (recentShoppingSpending > 7000 && monthlyBudget > 0) { // Example threshold
                    feedbackText += `\nüí° You spent ‚Çπ${recentShoppingSpending.toLocaleString('en-IN')} on Shopping recently. Consider window shopping!`;
                }

                feedbackEmojiEl.textContent = feedbackEmoji;
                feedbackTextEl.textContent = feedbackText;
            } catch (error) {
                console.error('Error updating feedback:', error);
                showMessage('Failed to update feedback messages.', 'error');
            }
        };

        /**
         * Updates the display and progress bar for the savings goal.
         */
        const updateSavingsGoalDisplay = () => {
            try {
                if (savingsGoal > 0) {
                    const percentage = (currentSavingsProgress / savingsGoal) * 100;
                    savingsProgressDisplay.textContent = `‚Çπ${currentSavingsProgress.toLocaleString('en-IN')} / ‚Çπ${savingsGoal.toLocaleString('en-IN')}`;
                    savingsProgressBar.style.width = `${Math.min(100, percentage).toFixed(0)}%`;
                    savingsProgressBar.classList.remove('bg-red-600');
                    if (percentage >= 100) {
                        savingsProgressBar.classList.add('bg-green-600');
                        showMessage('Congratulations! You\'ve reached your savings goal!', 'success');
                    } else if (percentage >= 75) {
                        savingsProgressBar.classList.add('bg-blue-600');
                    } else {
                        savingsProgressBar.classList.add('bg-yellow-500');
                    }
                } else {
                    savingsProgressDisplay.textContent = `‚Çπ0.00 / ‚Çπ0.00`;
                    savingsProgressBar.style.width = '0%';
                    savingsProgressBar.classList.remove('bg-green-600', 'bg-blue-600', 'bg-yellow-500', 'bg-red-600');
                }
            } catch (error) {
                console.error('Error updating savings goal display:', error);
                showMessage('Failed to update savings goal progress.', 'error');
            }
        };

        /**
         * Main update function that re-renders all UI components.
         */
        const updateUI = () => {
            try {
                populateCategoryDropdowns(); // Ensure categories are up-to-date before rendering lists
                renderTransactions();
                updateSummary();
                updateChart();
                updateFeedback();
                renderRecurringList(); // Ensure recurring list on main page is updated
                // Show/hide undo button based on lastUndoAction state
                if (lastUndoAction) {
                    undoLastPaidBtn.classList.remove('hidden');
                } else {
                    undoLastPaidBtn.classList.add('hidden');
                }
            } catch (error) {
                console.error('Error in updateUI:', error);
                showMessage('An error occurred while updating the display. Please refresh.', 'error');
            }
        };

        /**
         * SECTION: Modal Handling Functions
         * Functions to control the visibility and state of various modals.
         */

        /**
         * Shows a given modal with a smooth transition.
         * @param {HTMLElement} modalElement - The modal wrapper element.
         * @param {HTMLElement} contentElement - The modal content element for transitions.
         */
        const showModal = (modalElement, contentElement) => {
            resetIdleTimer();
            modalElement.classList.remove('hidden');
            setTimeout(() => {
                contentElement.classList.remove('scale-95', 'opacity-0');
                contentElement.classList.add('scale-100', 'opacity-100');
            }, 10);
        };

        /**
         * Hides a given modal with a smooth transition.
         * @param {HTMLElement} modalElement - The modal wrapper element.
         * @param {HTMLElement} contentElement - The modal content element for transitions.
         */
        const hideModal = (modalElement, contentElement) => {
            resetIdleTimer();
            contentElement.classList.remove('scale-100', 'opacity-100');
            contentElement.classList.add('scale-95', 'opacity-0');
            contentElement.addEventListener('transitionend', () => {
                modalElement.classList.add('hidden');
            }, { once: true });
        };

        /**
         * Toggles the visibility of expense-specific category fields in the Add Entry Modal.
         */
        const toggleExpenseCategoryFields = () => {
            try {
                if (entryType.value === 'Income') {
                    expenseCategoryGroup.classList.add('hidden');
                    detailedCategoryGroup.classList.add('hidden');
                    entryExpenseType.removeAttribute('required');
                    entryDetailedCategory.removeAttribute('required');
                } else {
                    expenseCategoryGroup.classList.remove('hidden');
                    detailedCategoryGroup.classList.remove('hidden');
                    entryExpenseType.setAttribute('required', 'required');
                    entryDetailedCategory.setAttribute('required', 'required');
                }
            } catch (error) {
                console.error('Error toggling expense category fields:', error);
            }
        };

        /**
         * SECTION: Form Submission Handlers
         * Functions to handle submissions of various forms.
         */

        /**
         * Handles form submission for new income/expense entries.
         * @param {Event} e - The form submission event.
         */
        const handleEntryFormSubmit = (e) => {
            e.preventDefault();
            try {
                resetIdleTimer();

                const type = entryType.value;
                const amount = parseFloat(entryAmount.value);
                const date = entryDate.value;
                const note = entryNote.value.trim();

                if (isNaN(amount) || amount <= 0) {
                    showMessage('Please enter a valid positive amount.', 'error');
                    return;
                }

                let newTransaction;
                if (type === 'Expense') {
                    const expenseType = entryExpenseType.value;
                    const detailedCategory = entryDetailedCategory.value;
                    if (!expenseType || !detailedCategory) {
                        showMessage('Please select both Expense Type and Detailed Category for expenses.', 'error');
                        return;
                    }
                    newTransaction = {
                        id: crypto.randomUUID(),
                        type,
                        amount,
                        expenseType, // 'Need', 'Want', 'Saving', 'Debt'
                        detailedCategory, // 'Food', 'Travel', etc.
                        date,
                        note
                    };
                } else { // Income
                    newTransaction = {
                        id: crypto.randomUUID(),
                        type,
                        amount,
                        date,
                        note
                    };
                }

                transactions.push(newTransaction);
                saveTransactions();
                console.log('--- Debugging handleEntryFormSubmit ---');
                console.log('New transaction added:', newTransaction);
                console.log('Transactions array after adding:', transactions);
                updateUI();
                hideModal(entryModal, modalContent);
                showMessage('Entry added successfully!', 'success');
            } catch (error) {
                console.error('Error adding new entry:', error);
                showMessage('Failed to add new entry. Please check your inputs.', 'error');
            }
        };

        /**
         * Handles setting the monthly budget.
         */
        const handleSetBudget = () => {
            try {
                resetIdleTimer();
                const newBudget = parseFloat(monthlyBudgetEl.value);
                if (isNaN(newBudget) || newBudget < 0) {
                    showMessage('Please enter a valid non-negative budget.', 'error');
                    return;
                }
                monthlyBudget = newBudget;
                saveBudget();
                updateFeedback();
                showMessage('Budget set successfully!', 'success');
            } catch (error) {
                console.error('Error setting budget:', error);
                showMessage('Failed to set budget.', 'error');
            }
        };

        /**
         * Handles adding a new custom category.
         */
        const handleAddCustomCategory = () => {
            try {
                const newCategory = newCustomCategoryInput.value.trim();
                if (newCategory) {
                    // Check if category already exists in default or custom categories
                    const defaultCategories = ['Food', 'Travel', 'Utilities', 'Rent', 'Shopping', 'Entertainment', 'Education', 'Healthcare', 'Transport', 'Other', 'Income', 'Saving', 'Debt'];
                    if (defaultCategories.includes(newCategory) || customCategories.includes(newCategory)) {
                        showMessage('Category already exists.', 'info');
                        return;
                    }
                    customCategories.push(newCategory);
                    saveCustomCategories();
                    populateCategoryDropdowns(); // Call this to update the list and dropdowns
                    newCustomCategoryInput.value = '';
                    showMessage(`Category "${newCategory}" added!`, 'success');
                } else {
                    showMessage('Please enter a category name.', 'error');
                }
            } catch (error) {
                console.error('Error adding custom category:', error);
                showMessage('Failed to add custom category.', 'error');
            }
        };

        /**
         * Handles removing a custom category.
         * @param {Event} e - The event object from the clicked remove button.
         */
        const handleRemoveCustomCategory = (e) => {
            try {
                const categoryToRemove = e.target.dataset.category;
                if (categoryToRemove) {
                    // Check if any existing transactions use this category before allowing removal
                    const isCategoryUsedInTransactions = transactions.some(t =>
                        t.detailedCategory === categoryToRemove || t.category === categoryToRemove // Check both fields just in case
                    );

                    if (isCategoryUsedInTransactions) {
                        showCustomConfirm(`Category "${categoryToRemove}" is currently used in some transactions. Removing it might affect your historical data display. Are you sure you want to proceed?`, () => {
                            performCategoryRemoval(categoryToRemove);
                        }, () => {
                            showMessage('Category removal cancelled.', 'info');
                        });
                    } else {
                        // Directly remove if not used in transactions
                        performCategoryRemoval(categoryToRemove);
                    }
                }
            } catch (error) {
                console.error('Error initiating custom category removal:', error);
                showMessage('Failed to remove custom category.', 'error');
            }
        };

        /**
         * Performs the actual removal of a custom category from the array and updates UI.
         * @param {string} categoryToRemove - The name of the category to remove.
         */
        const performCategoryRemoval = (categoryToRemove) => {
            customCategories = customCategories.filter(cat => cat !== categoryToRemove);
            saveCustomCategories();
            populateCategoryDropdowns(); // Re-render dropdowns and list
            // Re-render transactions to reflect potential changes in category display
            // (e.g., if a transaction used this category, it might now show 'N/A' or default)
            updateUI();
            showMessage(`Category "${categoryToRemove}" removed!`, 'success');
        };

        /**
         * Handles setting the savings goal.
         */
        const handleSetSavingsGoal = () => {
            try {
                const goal = parseFloat(savingsGoalInput.value);
                if (isNaN(goal) || goal < 0) {
                    showMessage('Please enter a valid non-negative savings goal.', 'error');
                    return;
                }
                savingsGoal = goal;
                saveSavingsGoal();
                updateSavingsGoalDisplay();
                showMessage('Savings goal set!', 'success');
            } catch (error) {
                console.error('Error setting savings goal:', error);
                showMessage('Failed to set savings goal.', 'error');
            }
        };


        /**
         * SECTION: Recurring Entries Logic
         * Manages recurring transaction schedules and their processing.
         */

        /**
         * Renders the list of scheduled recurring entries on the main page.
         */
        const renderRecurringList = () => {
            try {
                recurringListEl.innerHTML = '';
                if (recurringTransactions.length === 0) {
                    recurringListEl.innerHTML = '<p class="text-center text-purple-500 italic text-sm">No recurring entries scheduled.</p>';
                    return;
                }

                // Sort recurring transactions by next due date
                const sortedRecurring = [...recurringTransactions].sort((a, b) => new Date(a.nextDueDate) - new Date(b.nextDueDate));

                sortedRecurring.forEach(rec => {
                    const nextDue = new Date(rec.nextDueDate);
                    const today = new Date();
                    today.setHours(0, 0, 0, 0); // Normalize today's date to start of day for accurate comparison

                    let timeUntilDue = '';
                    const diffTime = nextDue.getTime() - today.getTime();
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // Calculate days remaining

                    if (diffDays === 0) {
                        timeUntilDue = 'Due Today!';
                    } else if (diffDays === 1) {
                        timeUntilDue = 'Due Tomorrow';
                    } else if (diffDays > 1) {
                        timeUntilDue = `${diffDays} days left`;
                    } else {
                        timeUntilDue = `${Math.abs(diffDays)} days overdue!`; // If negative, it's overdue
                    }

                    const recEl = document.createElement('div');
                    recEl.className = `flex justify-between items-center p-2 rounded-lg shadow-sm border bg-purple-100/60 border-purple-300 text-purple-800 glass-effect`;
                    recEl.innerHTML = `
                        <div class="flex-grow min-w-0">
                            <p class="font-semibold text-base truncate">‚Çπ${rec.amount.toLocaleString('en-IN')} - ${rec.detailedCategory} (${rec.expenseType})</p>
                            <p class="text-xs text-gray-600">Starts: ${new Date(rec.startDate).toLocaleDateString()} | Every: ${rec.recurrenceInterval}</p>
                            <p class="text-xs text-gray-600">Next Due: ${new Date(rec.nextDueDate).toLocaleDateString()} <span class="font-bold text-purple-700">(${timeUntilDue})</span></p>
                        </div>
                        <div class="flex items-center gap-1 flex-shrink-0">
                            <button data-id="${rec.id}" class="mark-paid-btn bg-purple-500 hover:bg-purple-600 text-white font-semibold py-1 px-2.5 rounded-lg shadow-md transition duration-200 ease-in-out text-xs">
                                Mark Paid
                            </button>
                            <button data-id="${rec.id}" class="delete-recurring-btn text-gray-500 hover:text-red-600 text-base p-0.5 rounded-full hover:bg-gray-200 transition-colors">
                                &times;
                            </button>
                        </div>
                    `;
                    recurringListEl.appendChild(recEl);
                });

                // Attach event listeners for delete and mark paid buttons in the recurring list
                document.querySelectorAll('#recurringList .delete-recurring-btn').forEach(button => {
                    button.onclick = (e) => {
                        try {
                            const idToDelete = e.target.dataset.id;
                            recurringTransactions = recurringTransactions.filter(rec => rec.id !== idToDelete);
                            saveRecurringTransactions();
                            renderRecurringList(); // Update the main page recurring list
                            renderCommittedNeedsDetailList(); // Also update committed needs modal if open
                            updateUI(); // Update the main UI (including committed needs total)
                            showMessage('Recurring entry deleted!', 'success');
                        } catch (error) {
                            console.error('Error deleting recurring entry:', error);
                            showMessage('Failed to delete recurring entry.', 'error');
                        }
                    };
                });

                document.querySelectorAll('#recurringList .mark-paid-btn').forEach(button => {
                    button.onclick = (e) => {
                        try {
                            const idToMarkPaid = e.target.dataset.id;
                            const recIndex = recurringTransactions.findIndex(rec => rec.id === idToMarkPaid);
                            if (recIndex !== -1) {
                                let currentRec = recurringTransactions[recIndex];
                                
                                // Store info for potential undo
                                lastUndoAction = {
                                    type: 'markPaid',
                                    recurringId: currentRec.id,
                                    oldNextDueDate: currentRec.nextDueDate,
                                    newTransactionId: null // Will be populated after transaction creation
                                };

                                // Add an actual transaction for this payment
                                const newTransaction = {
                                    id: crypto.randomUUID(),
                                    type: 'Expense',
                                    amount: currentRec.amount,
                                    expenseType: currentRec.expenseType,
                                    detailedCategory: currentRec.detailedCategory,
                                    date: new Date().toISOString().substring(0, 10), // Mark as paid today
                                    note: `Paid Recurring: ${currentRec.detailedCategory}`
                                };
                                transactions.push(newTransaction);
                                saveTransactions();

                                lastUndoAction.newTransactionId = newTransaction.id; // Store the new transaction's ID

                                // Advance the next due date to the next cycle
                                let nextDue = new Date(currentRec.nextDueDate);
                                if (currentRec.recurrenceInterval === 'monthly') {
                                    nextDue.setMonth(nextDue.getMonth() + 1);
                                } else if (currentRec.recurrenceInterval === 'weekly') {
                                    nextDue.setDate(nextDue.getDate() + 7);
                                }
                                currentRec.nextDueDate = nextDue.toISOString().substring(0, 10);
                                saveRecurringTransactions();
                                
                                renderRecurringList(); // Re-render the main page recurring list
                                renderCommittedNeedsDetailList(); // Re-render the committed needs detail modal
                                updateUI(); // Re-render the main UI to reflect new transaction and updated committed needs
                                showMessage('Recurring entry marked as paid for this cycle!', 'success');
                            }
                        } catch (error) {
                            console.error('Error marking recurring entry as paid:', error);
                            showMessage('Failed to mark recurring entry as paid.', 'error');
                        }
                    };
                });
            } catch (error) {
                console.error('Error rendering recurring list:', error);
                showMessage('Failed to display scheduled entries.', 'error');
            }
        };

        /**
         * Handles form submission for new recurring entries.
         * @param {Event} e - The form submission event.
         */
        const handleRecurringEntryFormSubmit = (e) => {
            e.preventDefault();
            try {
                resetIdleTimer();

                const amount = parseFloat(recurringAmount.value);
                const detailedCategory = recurringDetailedCategory.value;
                const expenseType = recurringExpenseType.value;
                const startDate = recurringStartDate.value;
                const interval = recurrenceInterval.value;

                if (isNaN(amount) || amount <= 0 || !detailedCategory || !expenseType || !startDate) {
                    showMessage('Please fill all required fields for recurring entry.', 'error');
                    return;
                }

                const newRecurringEntry = {
                    id: crypto.randomUUID(),
                    amount,
                    detailedCategory,
                    expenseType,
                    startDate,
                    recurrenceInterval: interval,
                    nextDueDate: startDate // Initial next due date is the start date
                };

                recurringTransactions.push(newRecurringEntry);
                saveRecurringTransactions();
                renderRecurringList(); // Update the recurring list on the main page
                updateUI(); // Update the main UI (including committed needs total)
                showMessage('Recurring entry scheduled!', 'success');
                
                hideModal(recurringEntryModal, recurringModalContent);
            } catch (error) {
                console.error('Error scheduling recurring entry:', error);
                showMessage('Failed to schedule recurring entry.', 'error');
            }
        };

        /**
         * Processes recurring entries on app load, adding transactions if due.
         */
        const processRecurringEntries = () => {
            try {
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Normalize to start of day

                let transactionsAdded = false;

                recurringTransactions.forEach(rec => {
                    let nextDue = new Date(rec.nextDueDate);
                    nextDue.setHours(0, 0, 0, 0);

                    while (nextDue <= today) {
                        // Check if a similar transaction already exists for this due date to prevent duplicates
                        const isDuplicate = transactions.some(t =>
                            t.type === 'Expense' &&
                            t.amount === rec.amount &&
                            t.detailedCategory === rec.detailedCategory &&
                            t.expenseType === rec.expenseType &&
                            t.date === nextDue.toISOString().substring(0, 10)
                        );

                        if (!isDuplicate) {
                            // Add transaction for this due date
                            const newTransaction = {
                                id: crypto.randomUUID(),
                                type: 'Expense',
                                amount: rec.amount,
                                expenseType: rec.expenseType,
                                detailedCategory: rec.detailedCategory,
                                date: nextDue.toISOString().substring(0, 10),
                                note: `Recurring: ${rec.detailedCategory} (${rec.recurrenceInterval})`
                            };
                            transactions.push(newTransaction);
                            transactionsAdded = true;
                        }

                        // Calculate next due date for the recurring schedule
                        if (rec.recurrenceInterval === 'monthly') {
                            nextDue.setMonth(nextDue.getMonth() + 1);
                        } else if (rec.recurrenceInterval === 'weekly') {
                            nextDue.setDate(nextDue.getDate() + 7);
                        }
                        rec.nextDueDate = nextDue.toISOString().substring(0, 10);
                    }
                });

                if (transactionsAdded) {
                    saveTransactions();
                    saveRecurringTransactions(); // Save updated nextDueDates
                    updateUI();
                    showMessage('Recurring expenses added automatically!', 'success');
                } else {
                    saveRecurringTransactions(); // Always save, even if no new transactions, to update nextDueDates
                }
            }
            catch (error) {
                console.error('Error processing recurring entries:', error);
                showMessage('An error occurred while processing scheduled entries.', 'error');
            }
        };

        /**
         * SECTION: Committed Needs Detail Modal Logic
         * Handles the display and actions within the committed needs detail modal.
         */

        /**
         * Renders the detailed list of committed needs for the current month.
         */
        const renderCommittedNeedsDetailList = () => {
            try {
                committedNeedsDetailList.innerHTML = '';
                const today = new Date();
                const currentMonth = today.getMonth();
                const currentYear = today.getFullYear();

                const currentMonthCommittedNeeds = recurringTransactions.filter(rec => {
                    const nextDue = new Date(rec.nextDueDate);
                    return rec.expenseType === 'Need' &&
                           nextDue.getMonth() === currentMonth &&
                           nextDue.getFullYear() === currentYear;
                }).sort((a, b) => new Date(a.nextDueDate) - new Date(b.nextDueDate)); // Sort by due date

                if (currentMonthCommittedNeeds.length === 0) {
                    committedNeedsDetailList.innerHTML = '<p class="text-center text-blue-500 italic text-sm">No committed needs scheduled for this month.</p>';
                    return;
                }

                currentMonthCommittedNeeds.forEach(rec => {
                    const nextDue = new Date(rec.nextDueDate);
                    today.setHours(0, 0, 0, 0);

                    let timeUntilDue = '';
                    const diffTime = nextDue.getTime() - today.getTime();
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) {
                        timeUntilDue = 'Due Today!';
                    } else if (diffDays === 1) {
                        timeUntilDue = 'Due Tomorrow';
                    } else if (diffDays > 1) {
                        timeUntilDue = `${diffDays} days left`;
                    } else {
                        timeUntilDue = `${Math.abs(diffDays)} days overdue!`;
                    }

                    const recEl = document.createElement('div');
                    recEl.className = `flex justify-between items-center p-2 rounded-lg shadow-sm border bg-blue-100/60 border-blue-300 text-blue-800 glass-effect`;
                    recEl.innerHTML = `
                        <div class="flex-grow min-w-0">
                            <p class="font-semibold text-base truncate">‚Çπ${rec.amount.toLocaleString('en-IN')} - ${rec.detailedCategory}</p>
                            <p class="text-xs text-gray-600">Next Due: ${nextDue.toLocaleDateString()} <span class="font-bold text-blue-700">(${timeUntilDue})</span></p>
                        </div>
                        <div class="flex items-center gap-1 flex-shrink-0">
                            <button data-id="${rec.id}" class="mark-paid-from-detail-btn bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-2.5 rounded-lg shadow-md transition duration-200 ease-in-out text-xs">
                                Mark Paid
                            </button>
                            <button data-id="${rec.id}" class="delete-recurring-btn text-gray-500 hover:text-red-600 text-base p-0.5 rounded-full hover:bg-gray-200 transition-colors">
                                &times;
                            </button>
                        </div>
                    `;
                    committedNeedsDetailList.appendChild(recEl);
                });

                // Attach event listeners for "Mark Paid" buttons in this modal
                document.querySelectorAll('#committedNeedsDetailList .mark-paid-from-detail-btn').forEach(button => {
                    button.onclick = (e) => {
                        try {
                            const idToMarkPaid = e.target.dataset.id;
                            const recIndex = recurringTransactions.findIndex(rec => rec.id === idToMarkPaid);
                            if (recIndex !== -1) {
                                let currentRec = recurringTransactions[recIndex];
                                
                                lastUndoAction = {
                                    type: 'markPaid',
                                    recurringId: currentRec.id,
                                    oldNextDueDate: currentRec.nextDueDate,
                                    newTransactionId: null
                                };

                                const newTransaction = {
                                    id: crypto.randomUUID(),
                                    type: 'Expense',
                                    amount: currentRec.amount,
                                    expenseType: currentRec.expenseType,
                                    detailedCategory: currentRec.detailedCategory,
                                    date: new Date().toISOString().substring(0, 10),
                                    note: `Paid Recurring: ${currentRec.detailedCategory}`
                                };
                                transactions.push(newTransaction);
                                saveTransactions();

                                lastUndoAction.newTransactionId = newTransaction.id;

                                let nextDue = new Date(currentRec.nextDueDate);
                                if (currentRec.recurrenceInterval === 'monthly') {
                                    nextDue.setMonth(nextDue.getMonth() + 1);
                                } else if (currentRec.recurrenceInterval === 'weekly') {
                                    nextDue.setDate(nextDue.getDate() + 7);
                                }
                                currentRec.nextDueDate = nextDue.toISOString().substring(0, 10);
                                saveRecurringTransactions();
                                
                                renderCommittedNeedsDetailList();
                                renderRecurringList();
                                updateUI();
                                showMessage('Recurring entry marked as paid!', 'success');
                            }
                        } catch (error) {
                            console.error('Error marking committed need as paid:', error);
                            showMessage('Failed to mark committed need as paid.', 'error');
                        }
                    };
                });

                // Attach event listeners for delete buttons in this modal
                document.querySelectorAll('#committedNeedsDetailList .delete-recurring-btn').forEach(button => {
                    button.onclick = (e) => {
                        try {
                            const idToDelete = e.target.dataset.id;
                            recurringTransactions = recurringTransactions.filter(rec => rec.id !== idToDelete);
                            saveRecurringTransactions();
                            renderCommittedNeedsDetailList();
                            renderRecurringList();
                            updateUI();
                            showMessage('Recurring entry deleted!', 'success');
                        } catch (error) {
                            console.error('Error deleting committed need:', error);
                            showMessage('Failed to delete committed need.', 'error');
                        }
                    };
                });
            } catch (error) {
                console.error('Error rendering committed needs detail list:', error);
                showMessage('Failed to display committed needs details.', 'error');
            }
        };

        /**
         * Handles undoing the last "Mark Paid" action.
         */
        const handleUndoLastPaid = () => {
            try {
                resetIdleTimer();
                if (!lastUndoAction || lastUndoAction.type !== 'markPaid') {
                    showMessage('No recent "Mark Paid" action to undo.', 'error');
                    return;
                }

                // 1. Remove the transaction that was just added
                transactions = transactions.filter(t => t.id !== lastUndoAction.newTransactionId);
                saveTransactions();

                // 2. Revert the nextDueDate of the recurring entry
                const recIndex = recurringTransactions.findIndex(rec => rec.id === lastUndoAction.recurringId);
                if (recIndex !== -1) {
                    recurringTransactions[recIndex].nextDueDate = lastUndoAction.oldNextDueDate;
                    saveRecurringTransactions();
                } else {
                    console.error("Could not find recurring transaction to undo nextDueDate. Data might be inconsistent.");
                    showMessage('Error: Could not find original recurring entry for undo. Data might be inconsistent.', 'error');
                }

                lastUndoAction = null; // Clear the undo action
                renderCommittedNeedsDetailList();
                renderRecurringList();
                updateUI();
                showMessage('Last "Mark Paid" action undone!', 'success');
            } catch (error) {
                console.error('Error undoing last paid action:', error);
                showMessage('Failed to undo last "Mark Paid" action.', 'error');
            }
        };

        /**
         * SECTION: Privacy Lock Logic
         * Handles the PIN-based privacy lock feature.
         */
        let unlockSessionActive = sessionStorage.getItem('unlockSessionActive') === 'true';

        /**
         * Shows the privacy lock modal.
         */
        const showLockModal = () => {
            try {
                if (unlockSessionActive) {
                    // If already unlocked in session, just ensure main content is visible and initialize app
                    mainAppContent.classList.remove('hidden');
                    initializeApp();
                    return;
                }

                privacyLockModal.classList.remove('hidden');
                setTimeout(() => {
                    lockModalContent.classList.remove('scale-95', 'opacity-0');
                    lockModalContent.classList.add('scale-100', 'opacity-100');
                }, 10);
                pinInput.value = '';
                pinError.classList.add('hidden');
                pinError.textContent = '';
                lockoutMessage.classList.add('hidden');

                if (lockoutEndTime > Date.now()) {
                    startLockoutCountdown();
                } else {
                    enablePinInputAndButton();
                }

                if (storedPIN) {
                    lockModalTitle.textContent = 'üîí Enter PIN';
                    unlockBtn.textContent = 'Unlock';
                    setNewPinBtn.classList.remove('hidden');
                    resetPinBtn.classList.remove('hidden');
                    forgotPinBtn.classList.remove('hidden'); 
                } else {
                    lockModalTitle.textContent = 'üîë Set Your PIN';
                    unlockBtn.textContent = 'Set PIN';
                    setNewPinBtn.classList.add('hidden');
                    resetPinBtn.classList.add('hidden');
                    forgotPinBtn.classList.add('hidden'); 
                }
                pinInput.focus();
            } catch (error) {
                console.error('Error showing lock modal:', error);
                showMessage('Failed to display lock screen.', 'error');
            }
        };

        /**
         * Hides the privacy lock modal.
         */
        const hideLockModal = () => {
            try {
                lockModalContent.classList.remove('scale-100', 'opacity-100');
                lockModalContent.classList.add('scale-95', 'opacity-0');
                lockModalContent.addEventListener('transitionend', () => {
                    privacyLockModal.classList.add('hidden');
                }, { once: true });
            } catch (error) {
                console.error('Error hiding lock modal:', error);
            }
        };

        /**
         * Disables PIN input and unlock button during lockout.
         */
        const disablePinInputAndButton = () => {
            pinInput.disabled = true;
            unlockBtn.disabled = true;
        };

        /**
         * Enables PIN input and unlock button after lockout.
         */
        const enablePinInputAndButton = () => {
            pinInput.disabled = false;
            unlockBtn.disabled = false;
            lockoutMessage.classList.add('hidden');
            clearInterval(lockoutIntervalId);
        };

        /**
         * Starts the lockout countdown timer.
         */
        const startLockoutCountdown = () => {
            try {
                disablePinInputAndButton();
                lockoutMessage.classList.remove('hidden');

                if (lockoutIntervalId) {
                    clearInterval(lockoutIntervalId);
                }

                lockoutIntervalId = setInterval(() => {
                    const timeLeft = Math.floor((lockoutEndTime - Date.now()) / 1000);
                    if (timeLeft <= 0) {
                        enablePinInputAndButton();
                        failedAttempts = 0;
                        localStorage.setItem('failedAttempts', failedAttempts);
                        localStorage.removeItem('lockoutEndTime');
                        showMessage('Lockout ended. Please try again.', 'success');
                        clearInterval(lockoutIntervalId);
                        lockoutMessage.classList.add('hidden');
                    } else {
                        lockoutTimerDisplay.textContent = timeLeft;
                    }
                }, 1000);
            } catch (error) {
                console.error('Error starting lockout countdown:', error);
                showMessage('Lockout timer error.', 'error');
            }
        };

        /**
         * Attempts to unlock the application using the entered PIN.
         */
        const unlockApp = () => {
            try {
                const enteredPIN = pinInput.value;
                pinError.classList.add('hidden');
                pinError.textContent = '';

                if (lockoutEndTime > Date.now()) {
                    pinError.textContent = 'Still in lockout period.';
                    pinError.classList.remove('hidden');
                    return;
                }

                if (!storedPIN) { // No PIN set yet, this is for setting the PIN
                    if (enteredPIN.length === 4 && /^\d+$/.test(enteredPIN)) {
                        savePIN(enteredPIN);
                        sessionStorage.setItem('unlockSessionActive', 'true');
                        hideLockModal();
                        // Directly show main content and initialize app
                        mainAppContent.classList.remove('hidden');
                        initializeApp();
                        showMessage('PIN set successfully!', 'success');
                        failedAttempts = 0;
                        localStorage.setItem('failedAttempts', failedAttempts);
                        startIdleTimer();
                    } else {
                        pinError.textContent = 'PIN must be 4 digits.';
                        pinError.classList.remove('hidden');
                    }
                } else { // PIN is already set, this is for unlocking
                    if (enteredPIN === storedPIN) {
                        sessionStorage.setItem('unlockSessionActive', 'true');
                        hideLockModal();
                        // Directly show main content and initialize app
                        mainAppContent.classList.remove('hidden');
                        initializeApp();
                        showMessage('App unlocked!', 'success');
                        failedAttempts = 0;
                        localStorage.setItem('failedAttempts', failedAttempts);
                        startIdleTimer();
                    } else {
                        failedAttempts++;
                        localStorage.setItem('failedAttempts', failedAttempts);
                        if (failedAttempts >= MAX_FAILED_ATTEMPTS) {
                            lockoutEndTime = Date.now() + (LOCKOUT_DURATION_SECONDS * 1000);
                            localStorage.setItem('lockoutEndTime', lockoutEndTime);
                            startLockoutCountdown();
                            pinError.textContent = 'Too many failed attempts.';
                            pinError.classList.remove('hidden');
                        } else {
                            pinError.textContent = `Invalid PIN. ${MAX_FAILED_ATTEMPTS - failedAttempts} attempts remaining.`;
                            pinError.classList.remove('hidden');
                        }
                    }
                }
            } catch (error) {
                console.error('Error unlocking app:', error);
                showMessage('An error occurred during unlock. Try refreshing.', 'error');
            }
        };

        /**
         * Prompts the user to set a new PIN, with validation.
         */
        const handleSetNewPin = () => {
            try {
                resetIdleTimer();
                let newPin = null;

                const currentPinCheck = prompt('Enter your CURRENT 4-digit PIN:');
                if (currentPinCheck === null) {
                    showMessage('PIN change cancelled.', 'info');
                    return;
                }
                if (currentPinCheck !== storedPIN) {
                    showMessage('Incorrect current PIN.', 'error');
                    return;
                }
                newPin = prompt('Enter NEW 4-digit PIN:');

                if (newPin === null) {
                    showMessage('PIN change cancelled.', 'info');
                    return;
                }

                if (newPin.length !== 4 || !/^\d+$/.test(newPin)) {
                    showMessage('New PIN must be exactly 4 digits.', 'error');
                    return;
                }

                const confirmPin = prompt('Confirm NEW 4-digit PIN:');
                if (confirmPin === null) {
                    showMessage('PIN change cancelled.', 'info');
                    return;
                }

                if (newPin === confirmPin) {
                    savePIN(newPin);
                    showMessage('New PIN set successfully!', 'success');
                } else {
                    showMessage('New PINs do not match. Please try again.', 'error');
                }
            } catch (error) {
                console.error('Error setting new PIN:', error);
                showMessage('Failed to set new PIN.', 'error');
            }
        };

        /**
         * Resets the application by clearing all data and PIN.
         */
        const handleResetApp = () => {
            try {
                resetIdleTimer();
                // Using a custom message box instead of confirm()
                showCustomConfirm('WARNING: This will clear your PIN and ALL transaction data. Are you sure? This is an irreversible action.', () => {
                    clearPIN();
                    localStorage.clear(); // Clear all app data
                    sessionStorage.removeItem('unlockSessionActive');
                    transactions = [];
                    monthlyBudget = 0;
                    customCategories = [];
                    savingsGoal = 0;
                    currentSavingsProgress = 0;
                    recurringTransactions = [];
                    failedAttempts = 0;
                    localStorage.removeItem('failedAttempts');
                    localStorage.removeItem('lockoutEndTime');
                    updateUI();
                    showMessage('App and PIN reset. All data cleared!', 'success');
                    location.reload(); // Reload to ensure a clean state
                }, () => {
                    showMessage('App reset cancelled.', 'info');
                });
            } catch (error) {
                console.error('Error resetting app:', error);
                showMessage('Failed to reset application data.', 'error');
            }
        };

        /**
         * Handles the "Forgot PIN" action, which also resets all data.
         */
        const handleForgotPin = () => {
            try {
                resetIdleTimer();
                // Using a custom message box instead of confirm()
                showCustomConfirm('WARNING: Forgetting your PIN will clear ALL your transaction data and reset the app. This action cannot be undone. Are you sure you want to proceed?', () => {
                    clearPIN();
                    localStorage.clear();
                    sessionStorage.removeItem('unlockSessionActive');
                    transactions = [];
                    monthlyBudget = 0;
                    customCategories = [];
                    savingsGoal = 0;
                    currentSavingsProgress = 0;
                    recurringTransactions = [];
                    failedAttempts = 0;
                    localStorage.removeItem('failedAttempts');
                    localStorage.removeItem('lockoutEndTime');
                    updateUI();
                    showMessage('PIN forgotten and app reset. All data cleared!', 'success');
                    location.reload();
                }, () => {
                    showMessage('Forgot PIN cancelled.', 'info');
                });
            } catch (error) {
                console.error('Error handling forgot PIN:', error);
                showMessage('Failed to process "Forgot PIN" request.', 'error');
            }
        };

        /**
         * SECTION: Idle Timer Logic
         * Automatically logs out the user after a period of inactivity.
         */

        /**
         * Starts the idle timeout timer.
         */
        const startIdleTimer = () => {
            clearTimeout(idleTimeoutTimerId);
            idleTimeoutTimerId = setTimeout(logout, IDLE_TIMEOUT_MS);
        };

        /**
         * Resets the idle timer on user activity.
         */
        const resetIdleTimer = () => {
            lastActivityTime = Date.now();
            if (sessionStorage.getItem('unlockSessionActive') === 'true') {
                startIdleTimer();
            }
        };

        /**
         * Logs out the user due to inactivity.
         */
        const logout = () => {
            try {
                clearTimeout(idleTimeoutTimerId);
                sessionStorage.removeItem('unlockSessionActive');
                mainAppContent.classList.add('hidden');
                showLockModal();
                showMessage('Logged out due to inactivity.', 'info');
            } catch (error) {
                console.error('Error during logout:', error);
                showMessage('An error occurred during logout.', 'error');
            }
        };

        /**
         * Custom confirm dialog implementation.
         * Replaces window.confirm for better UI control within the iframe.
         */
        function showCustomConfirm(message, onConfirm, onCancel) {
            const confirmBox = document.createElement('div');
            confirmBox.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9999]';
            confirmBox.innerHTML = `
                <div class="modal-glass-effect rounded-2xl shadow-xl p-6 w-full max-w-sm text-center">
                    <p class="text-xl font-semibold text-gray-800 mb-6">${message}</p>
                    <div class="flex justify-center gap-4">
                        <button id="confirmYes" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition">Yes</button>
                        <button id="confirmNo" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-md transition">No</button>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmBox);

            document.getElementById('confirmYes').onclick = () => {
                onConfirm();
                document.body.removeChild(confirmBox);
            };
            document.getElementById('confirmNo').onclick = () => {
                onCancel();
                document.body.removeChild(confirmBox);
            };
        }

        /**
         * SECTION: Data Export Functions
         * Handles exporting transaction data to CSV and PDF formats.
         */

        /**
         * Exports transaction data to a CSV file.
         */
        const exportToCSV = () => {
            try {
                const selectedDetailedCategory = filterDetailedCategoryEl.value;
                const selectedMonth = filterMonthEl.value;

                const filteredTransactions = transactions.filter(t => {
                    const matchesCategory = selectedDetailedCategory === 'All' ||
                                            (t.type === 'Income' && selectedDetailedCategory === 'Income') ||
                                            (t.type === 'Expense' && t.detailedCategory === selectedDetailedCategory) ||
                                            (t.type === 'Expense' && t.expenseType === selectedDetailedCategory);
                    const transactionMonth = new Date(t.date).toISOString().substring(0, 7);
                    const matchesMonth = !selectedMonth || transactionMonth === selectedMonth;
                    return matchesCategory && matchesMonth;
                }).sort((a, b) => new Date(b.date) - new Date(a.date));

                if (filteredTransactions.length === 0) {
                    showMessage('No data to export for current filters!', 'error');
                    return;
                }

                let csvContent = "data:text/csv;charset=utf-8,";
                csvContent += "Date,Type,Expense Type,Detailed Category,Amount,Note\n";

                filteredTransactions.forEach(t => {
                    const row = [
                        `"${t.date}"`,
                        `"${t.type}"`,
                        `"${t.expenseType || 'N/A'}"`,
                        `"${t.detailedCategory || 'N/A'}"`,
                        t.amount,
                        `"${t.note ? t.note.replace(/"/g, '""') : ''}"`
                    ].join(",");
                    csvContent += row + "\n";
                });

                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                const fileName = `transactions_${selectedMonth || 'all'}_${selectedDetailedCategory || 'all'}.csv`;
                link.setAttribute("download", fileName);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage('Data exported to CSV!', 'success');
            } catch (error) {
                console.error('Error exporting to CSV:', error);
                showMessage('Failed to export data to CSV. Please try again.', 'error');
            }
        };

        /**
         * Exports transaction data to a PDF file.
         */
        const exportToPDF = async () => {
            try {
                // Hide the main application content temporarily to avoid capturing it directly
                mainAppContent.classList.add('hidden');

                // Create a temporary div to render the PDF content with specific styles for PDF
                const tempDiv = document.createElement('div');
                tempDiv.className = "bg-white p-4 rounded-lg shadow-xl mx-auto w-full max-w-4xl border border-indigo-100";
                document.body.appendChild(tempDiv);

                // Populate the temporary div with content, adjusting font sizes
                tempDiv.innerHTML = `
                    <div class="p-2">
                        <h1 class="text-xl sm:text-2xl font-bold text-center text-indigo-700 mb-4 border-b border-indigo-200 pb-2">
                            Income-Expense Report
                        </h1>
                        <div id="pdf-summary" class="grid grid-cols-2 gap-2 mb-4">
                            <div class="bg-gradient-to-r from-green-500 to-green-600 text-white p-3 rounded-lg shadow-md text-center">
                                <p class="text-xs uppercase opacity-90">Total Income</p>
                                <p class="text-xl font-bold">${totalIncomeEl.textContent}</p>
                            </div>
                            <div class="bg-gradient-to-r from-red-500 to-red-600 text-white p-3 rounded-lg shadow-md text-center">
                                <p class="text-xs uppercase opacity-90">Total Expense</p>
                                <p class="text-xl font-bold">${totalExpenseEl.textContent}</p>
                            </div>
                            <div class="bg-gradient-to-r from-blue-500 to-blue-600 text-white p-3 rounded-lg shadow-md text-center">
                                <p class="text-xs uppercase opacity-90">Balance</p>
                                <p class="text-xl font-bold">${balanceEl.textContent}</p>
                            </div>
                            <div class="bg-gradient-to-r from-purple-500 to-purple-600 text-white p-3 rounded-lg shadow-md text-center">
                                <p class="text-xs uppercase opacity-90">Savings</p>
                                <p class="text-xl font-bold">${totalSavingsEl.textContent}</p>
                            </div>
                        </div>
                        <div id="pdf-feedback" class="bg-indigo-50 p-4 rounded-lg shadow-inner mb-4 text-center border border-indigo-200">
                            <p class="text-xl mb-1">${feedbackEmojiEl.textContent}</p>
                            <p class="text-base font-medium">${feedbackTextEl.textContent}</p>
                        </div>
                        <h2 class="text-xl font-semibold text-indigo-700 mb-3 border-b border-indigo-200 pb-1">Transactions for ${filterMonthEl.value || 'All Months'} (${filterDetailedCategoryEl.value || 'All Categories'})</h2>
                        <div id="pdf-transaction-list" class="space-y-2 text-sm">
                            ${Array.from(transactionListEl.children).map(node => {
                                // Clone and adjust styles for PDF
                                const clonedNode = node.cloneNode(true);
                                clonedNode.classList.remove('p-3', 'text-lg', 'text-xl'); // Remove existing size classes
                                clonedNode.classList.add('p-2', 'text-sm'); // Add smaller size classes for PDF
                                clonedNode.querySelector('.font-semibold.text-lg')?.classList.replace('text-lg', 'text-base'); // Adjust note/category font
                                clonedNode.querySelector('.font-bold.text-xl')?.classList.replace('text-xl', 'text-lg'); // Adjust amount font
                                clonedNode.querySelector('.text-sm.text-gray-600')?.classList.replace('text-sm', 'text-xs'); // Adjust date font
                                return clonedNode.outerHTML;
                            }).join('')}
                        </div>
                        <h2 class="text-xl font-semibold text-indigo-700 mt-6 mb-3 border-b border-indigo-200 pb-1 text-center">Spending Breakdown (Current Month)</h2>
                        <div id="pdf-chart-container" class="relative w-full max-w-sm mx-auto aspect-square"></div>
                    </div>
                `;

                // Append chart image to the temporary div
                const chartCanvas = document.getElementById('spendingChart');
                if (chartCanvas && chartCanvas.chart) {
                    const chartImg = document.createElement('img');
                    chartImg.src = chartCanvas.toDataURL('image/png');
                    chartImg.style.width = '100%';
                    chartImg.style.height = 'auto';
                    document.getElementById('pdf-chart-container').appendChild(chartImg);
                } else {
                    const chartStatus = document.createElement('p');
                    chartStatus.textContent = 'No chart data available for PDF.';
                    chartStatus.className = 'text-center text-indigo-500 italic mt-4';
                    document.getElementById('pdf-chart-container').appendChild(chartStatus);
                }

                showMessage('Generating PDF...', 'info');

                const element = tempDiv;
                const { jsPDF } = window.jspdf;

                const canvas = await html2canvas(element, {
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    windowWidth: tempDiv.scrollWidth,
                    windowHeight: tempDiv.scrollHeight,
                });

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF('p', 'mm', 'a4');
                const imgWidth = 210;
                const pageHeight = 297;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;
                let heightLeft = imgHeight;
                let position = 0;

                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight;
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                const selectedMonth = filterMonthEl.value;
                const fileName = `expense_report_${selectedMonth || 'all'}.pdf`;
                pdf.save(fileName);
                showMessage('PDF exported successfully!', 'success');

            } catch (error) {
                console.error('Error generating PDF:', error);
                showMessage('Error generating PDF. Please try again.', 'error');
            } finally {
                // Restore main content display and remove temporary div
                mainAppContent.classList.remove('hidden');
                if (document.body.contains(tempDiv)) {
                    document.body.removeChild(tempDiv);
                }
            }
        };

        /**
         * SECTION: Carousel Logic
         * Handles auto-sliding image carousels.
         */

        /**
         * Sets up an auto-sliding carousel.
         * @param {string} carouselId - The ID of the carousel container.
         * @param {number} intervalTime - The time in milliseconds between slides.
         * @param {string} dotClass - The class name for carousel navigation dots.
         * @returns {number} - The interval ID for clearing later.
         */
        const setupCarousel = (carouselId, intervalTime, dotClass) => {
            const carousel = document.getElementById(carouselId);
            if (!carousel) {
                console.warn(`Carousel with ID "${carouselId}" not found.`);
                return null;
            }
            const inner = carousel.querySelector('.carousel-inner');
            const items = Array.from(carousel.querySelectorAll('.carousel-item'));
            const dots = Array.from(carousel.querySelectorAll(`.${dotClass}`));
            let currentIndex = 0;

            const updateCarousel = () => {
                const offset = -currentIndex * 100;
                inner.style.transform = `translateX(${offset}%)`;

                dots.forEach((dot, index) => {
                    if (index === currentIndex) {
                        dot.classList.add('active', 'opacity-70');
                        dot.classList.remove('opacity-40');
                    } else {
                        dot.classList.remove('active', 'opacity-70');
                        dot.classList.add('opacity-40');
                    }
                });
            };

            const nextSlide = () => {
                currentIndex = (currentIndex + 1) % items.length;
                updateCarousel();
            };

            dots.forEach((dot, index) => {
                dot.addEventListener('click', () => {
                    currentIndex = index;
                    updateCarousel();
                    // Reset auto-slide timer on manual navigation
                    clearInterval(currentInterval);
                    currentInterval = setInterval(nextSlide, intervalTime);
                });
            });

            let currentInterval = setInterval(nextSlide, intervalTime);
            updateCarousel(); // Initialize first slide
            return currentInterval;
        };


        /**
         * SECTION: Initialization & Event Listeners
         * Sets up the application on load and attaches all event listeners.
         */

        /**
         * Initializes the application by loading data and updating the UI.
         */
        const initializeApp = () => {
            try {
                loadTransactions();
                loadBudget();
                loadRecurringTransactions();
                loadCustomCategories(); // Load custom categories
                loadSavingsGoal(); // Load savings goal

                // Process recurring entries before rendering anything
                processRecurringEntries();

                // Set current month for filter
                const today = new Date();
                const currentMonthFormatted = today.toISOString().substring(0, 7);
                filterMonthEl.value = currentMonthFormatted;

                updateUI(); // Initial UI render

                // Setup carousels
                bannerCarouselInterval = setupCarousel('bannerCarousel', 5000, 'carousel-dot'); // 5 seconds
                brandsCarouselInterval = setupCarousel('trustedBrandsCarousel', 8000, 'carousel-dot-brands'); // 8 seconds for slower loop
            } catch (error) {
                console.error('Error initializing app:', error);
                showMessage('Failed to initialize the application. Data might not load correctly.', 'error');
            }
        };

        // Event Listeners
        addEntryBtn.onclick = () => showModal(entryModal, modalContent);
        cancelEntryBtn.onclick = () => hideModal(entryModal, modalContent);
        entryType.onchange = toggleExpenseCategoryFields;
        entryForm.onsubmit = handleEntryFormSubmit;

        setBudgetBtn.onclick = handleSetBudget;

        filterDetailedCategoryEl.onchange = () => { resetIdleTimer(); updateUI(); };
        filterMonthEl.onchange = () => { resetIdleTimer(); updateUI(); };

        exportCsvBtn.onclick = exportToCSV;
        exportPdfBtn.onclick = exportToPDF;

        addRecurringEntryBtn.onclick = () => showModal(recurringEntryModal, recurringModalContent);
        cancelRecurringBtn.onclick = () => hideModal(recurringEntryModal, recurringModalContent);
        recurringEntryForm.onsubmit = handleRecurringEntryFormSubmit;

        viewMoreCommittedNeedsBtn.onclick = () => { showModal(committedNeedsDetailModal, committedNeedsDetailModalContent); renderCommittedNeedsDetailList(); };
        closeCommittedNeedsDetailBtn.onclick = () => hideModal(committedNeedsDetailModal, committedNeedsDetailModalContent);
        undoLastPaidBtn.onclick = handleUndoLastPaid;

        unlockBtn.onclick = unlockApp;
        pinInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                unlockApp();
            }
        });
        setNewPinBtn.onclick = handleSetNewPin;
        resetPinBtn.onclick = handleResetApp;
        forgotPinBtn.onclick = handleForgotPin;

        addCustomCategoryBtn.onclick = handleAddCustomCategory;
        setSavingsGoalBtn.onclick = handleSetSavingsGoal;


        // Add event listeners for user activity to reset idle timer
        ['mousemove', 'mousedown', 'keypress', 'scroll', 'touchstart'].forEach(event => {
            document.addEventListener(event, resetIdleTimer, true);
        });

        /**
         * SECTION: Window Load Handler
         * Entry point for the application when the window finishes loading.
         */
        window.onload = () => {
            loadPIN(); // Try to load stored PIN

            if (storedPIN) {
                // If a PIN is set, immediately show the lock modal.
                // The unlockApp function will handle showing mainAppContent and initializing the app.
                appLoader.classList.add('hidden'); // Hide loader quickly
                showLockModal();
            } else {
                // If no PIN is set (first run or data cleared),
                // show loader briefly, then display the main app and the "Set PIN" modal.
                appLoader.classList.remove('hidden'); // Ensure loader is visible
                setTimeout(() => {
                    appLoader.style.opacity = '0'; // Fade out loader
                    appLoader.addEventListener('transitionend', () => {
                        appLoader.classList.add('hidden');
                        mainAppContent.classList.remove('hidden'); // Show main app content
                        initializeApp(); // Initialize the app AFTER main content is visible
                        showLockModal(); // Show modal to set PIN
                    }, { once: true });
                }, 500); // Loader displays for 0.5 seconds
            }
            // Initialize idle timer if already unlocked (e.g., from previous session/tab)
            if (sessionStorage.getItem('unlockSessionActive') === 'true') {
                 startIdleTimer();
            }
        };
    </script>
</body>
</html>
